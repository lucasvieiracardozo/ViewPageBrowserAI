{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://viewpagebrowserai/./node_modules/@google/generative-ai/dist/index.mjs","webpack://viewpagebrowserai/./src/background/config.ts","webpack://viewpagebrowserai/./src/utils/cache.ts","webpack://viewpagebrowserai/./src/utils/errors.ts","webpack://viewpagebrowserai/./src/utils/fullPageCapture.ts","webpack://viewpagebrowserai/./src/utils/performance.ts","webpack://viewpagebrowserai/./src/utils/webSearch.ts","webpack://viewpagebrowserai/webpack/bootstrap","webpack://viewpagebrowserai/webpack/runtime/define property getters","webpack://viewpagebrowserai/webpack/runtime/hasOwnProperty shorthand","webpack://viewpagebrowserai/webpack/runtime/make namespace object","webpack://viewpagebrowserai/./src/background/main.ts"],"sourcesContent":["/**\n * Contains the list of OpenAPI data types\n * as defined by https://swagger.io/docs/specification/data-models/data-types/\n * @public\n */\nvar SchemaType;\n(function (SchemaType) {\n    /** String type. */\n    SchemaType[\"STRING\"] = \"string\";\n    /** Number type. */\n    SchemaType[\"NUMBER\"] = \"number\";\n    /** Integer type. */\n    SchemaType[\"INTEGER\"] = \"integer\";\n    /** Boolean type. */\n    SchemaType[\"BOOLEAN\"] = \"boolean\";\n    /** Array type. */\n    SchemaType[\"ARRAY\"] = \"array\";\n    /** Object type. */\n    SchemaType[\"OBJECT\"] = \"object\";\n})(SchemaType || (SchemaType = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @public\n */\nvar ExecutableCodeLanguage;\n(function (ExecutableCodeLanguage) {\n    ExecutableCodeLanguage[\"LANGUAGE_UNSPECIFIED\"] = \"language_unspecified\";\n    ExecutableCodeLanguage[\"PYTHON\"] = \"python\";\n})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));\n/**\n * Possible outcomes of code execution.\n * @public\n */\nvar Outcome;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"outcome_unspecified\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"outcome_ok\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the\n     * reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"outcome_failed\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not\n     * be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"outcome_deadline_exceeded\";\n})(Outcome || (Outcome = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Possible roles.\n * @public\n */\nconst POSSIBLE_ROLES = [\"user\", \"model\", \"function\", \"system\"];\n/**\n * Harm categories that would cause prompts or candidates to be blocked.\n * @public\n */\nvar HarmCategory;\n(function (HarmCategory) {\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n})(HarmCategory || (HarmCategory = {}));\n/**\n * Threshold above which a prompt or candidate will be blocked.\n * @public\n */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n    /** Threshold is unspecified. */\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /** Content with NEGLIGIBLE will be allowed. */\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /** Content with NEGLIGIBLE and LOW will be allowed. */\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /** Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed. */\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /** All content will be allowed. */\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/**\n * Probability that a prompt or candidate matches a harm category.\n * @public\n */\nvar HarmProbability;\n(function (HarmProbability) {\n    /** Probability is unspecified. */\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /** Content has a negligible chance of being unsafe. */\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /** Content has a low chance of being unsafe. */\n    HarmProbability[\"LOW\"] = \"LOW\";\n    /** Content has a medium chance of being unsafe. */\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /** Content has a high chance of being unsafe. */\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/**\n * Reason that a prompt was blocked.\n * @public\n */\nvar BlockReason;\n(function (BlockReason) {\n    // A blocked reason was not specified.\n    BlockReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    // Content was blocked by safety settings.\n    BlockReason[\"SAFETY\"] = \"SAFETY\";\n    // Content was blocked, but the reason is uncategorized.\n    BlockReason[\"OTHER\"] = \"OTHER\";\n})(BlockReason || (BlockReason = {}));\n/**\n * Reason that a candidate finished.\n * @public\n */\nvar FinishReason;\n(function (FinishReason) {\n    // Default value. This value is unused.\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    // Natural stop point of the model or provided stop sequence.\n    FinishReason[\"STOP\"] = \"STOP\";\n    // The maximum number of tokens as specified in the request was reached.\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    // The candidate content was flagged for safety reasons.\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    // The candidate content was flagged for recitation reasons.\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    // The candidate content was flagged for using an unsupported language.\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    // Token generation stopped because the content contains forbidden terms.\n    FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    // Token generation stopped for potentially containing prohibited content.\n    FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    // Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n    FinishReason[\"SPII\"] = \"SPII\";\n    // The function call generated by the model is invalid.\n    FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    // Unknown reason.\n    FinishReason[\"OTHER\"] = \"OTHER\";\n})(FinishReason || (FinishReason = {}));\n/**\n * Task type for embedding content.\n * @public\n */\nvar TaskType;\n(function (TaskType) {\n    TaskType[\"TASK_TYPE_UNSPECIFIED\"] = \"TASK_TYPE_UNSPECIFIED\";\n    TaskType[\"RETRIEVAL_QUERY\"] = \"RETRIEVAL_QUERY\";\n    TaskType[\"RETRIEVAL_DOCUMENT\"] = \"RETRIEVAL_DOCUMENT\";\n    TaskType[\"SEMANTIC_SIMILARITY\"] = \"SEMANTIC_SIMILARITY\";\n    TaskType[\"CLASSIFICATION\"] = \"CLASSIFICATION\";\n    TaskType[\"CLUSTERING\"] = \"CLUSTERING\";\n})(TaskType || (TaskType = {}));\n/**\n * @public\n */\nvar FunctionCallingMode;\n(function (FunctionCallingMode) {\n    // Unspecified function calling mode. This value should not be used.\n    FunctionCallingMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    // Default model behavior, model decides to predict either a function call\n    // or a natural language repspose.\n    FunctionCallingMode[\"AUTO\"] = \"AUTO\";\n    // Model is constrained to always predicting a function call only.\n    // If \"allowed_function_names\" are set, the predicted function call will be\n    // limited to any one of \"allowed_function_names\", else the predicted\n    // function call will be any one of the provided \"function_declarations\".\n    FunctionCallingMode[\"ANY\"] = \"ANY\";\n    // Model will not predict any function call. Model behavior is same as when\n    // not passing any function declarations.\n    FunctionCallingMode[\"NONE\"] = \"NONE\";\n})(FunctionCallingMode || (FunctionCallingMode = {}));\n/**\n * The mode of the predictor to be used in dynamic retrieval.\n * @public\n */\nvar DynamicRetrievalMode;\n(function (DynamicRetrievalMode) {\n    // Unspecified function calling mode. This value should not be used.\n    DynamicRetrievalMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    // Run retrieval only when system decides it is necessary.\n    DynamicRetrievalMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Basic error type for this SDK.\n * @public\n */\nclass GoogleGenerativeAIError extends Error {\n    constructor(message) {\n        super(`[GoogleGenerativeAI Error]: ${message}`);\n    }\n}\n/**\n * Errors in the contents of a response from the model. This includes parsing\n * errors, or responses including a safety block reason.\n * @public\n */\nclass GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n    }\n}\n/**\n * Error class covering HTTP errors when calling the server. Includes HTTP\n * status, statusText, and optional details, if provided in the server response.\n * @public\n */\nclass GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {\n    constructor(message, status, statusText, errorDetails) {\n        super(message);\n        this.status = status;\n        this.statusText = statusText;\n        this.errorDetails = errorDetails;\n    }\n}\n/**\n * Errors in the contents of a request originating from user input.\n * @public\n */\nclass GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {\n}\n/**\n * Error thrown when a request is aborted, either due to a timeout or\n * intentional cancellation by the user.\n * @public\n */\nclass GoogleGenerativeAIAbortError extends GoogleGenerativeAIError {\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_BASE_URL = \"https://generativelanguage.googleapis.com\";\nconst DEFAULT_API_VERSION = \"v1beta\";\n/**\n * We can't `require` package.json if this runs on web. We will use rollup to\n * swap in the version number here at build time.\n */\nconst PACKAGE_VERSION = \"0.24.1\";\nconst PACKAGE_LOG_HEADER = \"genai-js\";\nvar Task;\n(function (Task) {\n    Task[\"GENERATE_CONTENT\"] = \"generateContent\";\n    Task[\"STREAM_GENERATE_CONTENT\"] = \"streamGenerateContent\";\n    Task[\"COUNT_TOKENS\"] = \"countTokens\";\n    Task[\"EMBED_CONTENT\"] = \"embedContent\";\n    Task[\"BATCH_EMBED_CONTENTS\"] = \"batchEmbedContents\";\n})(Task || (Task = {}));\nclass RequestUrl {\n    constructor(model, task, apiKey, stream, requestOptions) {\n        this.model = model;\n        this.task = task;\n        this.apiKey = apiKey;\n        this.stream = stream;\n        this.requestOptions = requestOptions;\n    }\n    toString() {\n        var _a, _b;\n        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;\n        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;\n        let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;\n        if (this.stream) {\n            url += \"?alt=sse\";\n        }\n        return url;\n    }\n}\n/**\n * Simple, but may become more complex if we add more versions to log.\n */\nfunction getClientHeaders(requestOptions) {\n    const clientHeaders = [];\n    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {\n        clientHeaders.push(requestOptions.apiClient);\n    }\n    clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);\n    return clientHeaders.join(\" \");\n}\nasync function getHeaders(url) {\n    var _a;\n    const headers = new Headers();\n    headers.append(\"Content-Type\", \"application/json\");\n    headers.append(\"x-goog-api-client\", getClientHeaders(url.requestOptions));\n    headers.append(\"x-goog-api-key\", url.apiKey);\n    let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;\n    if (customHeaders) {\n        if (!(customHeaders instanceof Headers)) {\n            try {\n                customHeaders = new Headers(customHeaders);\n            }\n            catch (e) {\n                throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);\n            }\n        }\n        for (const [headerName, headerValue] of customHeaders.entries()) {\n            if (headerName === \"x-goog-api-key\") {\n                throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);\n            }\n            else if (headerName === \"x-goog-api-client\") {\n                throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);\n            }\n            headers.append(headerName, headerValue);\n        }\n    }\n    return headers;\n}\nasync function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {\n    const url = new RequestUrl(model, task, apiKey, stream, requestOptions);\n    return {\n        url: url.toString(),\n        fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: \"POST\", headers: await getHeaders(url), body }),\n    };\n}\nasync function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, \n// Allows this to be stubbed for tests\nfetchFn = fetch) {\n    const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);\n    return makeRequest(url, fetchOptions, fetchFn);\n}\nasync function makeRequest(url, fetchOptions, fetchFn = fetch) {\n    let response;\n    try {\n        response = await fetchFn(url, fetchOptions);\n    }\n    catch (e) {\n        handleResponseError(e, url);\n    }\n    if (!response.ok) {\n        await handleResponseNotOk(response, url);\n    }\n    return response;\n}\nfunction handleResponseError(e, url) {\n    let err = e;\n    if (err.name === \"AbortError\") {\n        err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);\n        err.stack = e.stack;\n    }\n    else if (!(e instanceof GoogleGenerativeAIFetchError ||\n        e instanceof GoogleGenerativeAIRequestInputError)) {\n        err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);\n        err.stack = e.stack;\n    }\n    throw err;\n}\nasync function handleResponseNotOk(response, url) {\n    let message = \"\";\n    let errorDetails;\n    try {\n        const json = await response.json();\n        message = json.error.message;\n        if (json.error.details) {\n            message += ` ${JSON.stringify(json.error.details)}`;\n            errorDetails = json.error.details;\n        }\n    }\n    catch (e) {\n        // ignored\n    }\n    throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);\n}\n/**\n * Generates the request options to be passed to the fetch API.\n * @param requestOptions - The user-defined request options.\n * @returns The generated request options.\n */\nfunction buildFetchOptions(requestOptions) {\n    const fetchOptions = {};\n    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n        const controller = new AbortController();\n        if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n            setTimeout(() => controller.abort(), requestOptions.timeout);\n        }\n        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {\n            requestOptions.signal.addEventListener(\"abort\", () => {\n                controller.abort();\n            });\n        }\n        fetchOptions.signal = controller.signal;\n    }\n    return fetchOptions;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Adds convenience helper methods to a response object, including stream\n * chunks (as long as each chunk is a complete GenerateContentResponse JSON).\n */\nfunction addHelpers(response) {\n    response.text = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning text from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            return getText(response);\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return \"\";\n    };\n    /**\n     * TODO: remove at next major version\n     */\n    response.functionCall = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning function calls from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            console.warn(`response.functionCall() is deprecated. ` +\n                `Use response.functionCalls() instead.`);\n            return getFunctionCalls(response)[0];\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return undefined;\n    };\n    response.functionCalls = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning function calls from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            return getFunctionCalls(response);\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return undefined;\n    };\n    return response;\n}\n/**\n * Returns all text found in all parts of first candidate.\n */\nfunction getText(response) {\n    var _a, _b, _c, _d;\n    const textStrings = [];\n    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {\n        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {\n            if (part.text) {\n                textStrings.push(part.text);\n            }\n            if (part.executableCode) {\n                textStrings.push(\"\\n```\" +\n                    part.executableCode.language +\n                    \"\\n\" +\n                    part.executableCode.code +\n                    \"\\n```\\n\");\n            }\n            if (part.codeExecutionResult) {\n                textStrings.push(\"\\n```\\n\" + part.codeExecutionResult.output + \"\\n```\\n\");\n            }\n        }\n    }\n    if (textStrings.length > 0) {\n        return textStrings.join(\"\");\n    }\n    else {\n        return \"\";\n    }\n}\n/**\n * Returns functionCall of first candidate.\n */\nfunction getFunctionCalls(response) {\n    var _a, _b, _c, _d;\n    const functionCalls = [];\n    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {\n        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {\n            if (part.functionCall) {\n                functionCalls.push(part.functionCall);\n            }\n        }\n    }\n    if (functionCalls.length > 0) {\n        return functionCalls;\n    }\n    else {\n        return undefined;\n    }\n}\nconst badFinishReasons = [\n    FinishReason.RECITATION,\n    FinishReason.SAFETY,\n    FinishReason.LANGUAGE,\n];\nfunction hadBadFinishReason(candidate) {\n    return (!!candidate.finishReason &&\n        badFinishReasons.includes(candidate.finishReason));\n}\nfunction formatBlockErrorMessage(response) {\n    var _a, _b, _c;\n    let message = \"\";\n    if ((!response.candidates || response.candidates.length === 0) &&\n        response.promptFeedback) {\n        message += \"Response was blocked\";\n        if ((_a = response.promptFeedback) === null || _a === void 0 ? void 0 : _a.blockReason) {\n            message += ` due to ${response.promptFeedback.blockReason}`;\n        }\n        if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {\n            message += `: ${response.promptFeedback.blockReasonMessage}`;\n        }\n    }\n    else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {\n        const firstCandidate = response.candidates[0];\n        if (hadBadFinishReason(firstCandidate)) {\n            message += `Candidate was blocked due to ${firstCandidate.finishReason}`;\n            if (firstCandidate.finishMessage) {\n                message += `: ${firstCandidate.finishMessage}`;\n            }\n        }\n    }\n    return message;\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst responseLineRE = /^data\\: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * Process a response.body stream from the backend and return an\n * iterator that provides one complete GenerateContentResponse at a time\n * and a promise that resolves with a single aggregated\n * GenerateContentResponse.\n *\n * @param response - Response from a fetch call\n */\nfunction processStream(response) {\n    const inputStream = response.body.pipeThrough(new TextDecoderStream(\"utf8\", { fatal: true }));\n    const responseStream = getResponseStream(inputStream);\n    const [stream1, stream2] = responseStream.tee();\n    return {\n        stream: generateResponseSequence(stream1),\n        response: getResponsePromise(stream2),\n    };\n}\nasync function getResponsePromise(stream) {\n    const allResponses = [];\n    const reader = stream.getReader();\n    while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n            return addHelpers(aggregateResponses(allResponses));\n        }\n        allResponses.push(value);\n    }\n}\nfunction generateResponseSequence(stream) {\n    return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {\n        const reader = stream.getReader();\n        while (true) {\n            const { value, done } = yield __await(reader.read());\n            if (done) {\n                break;\n            }\n            yield yield __await(addHelpers(value));\n        }\n    });\n}\n/**\n * Reads a raw stream from the fetch response and join incomplete\n * chunks, returning a new stream that provides a single complete\n * GenerateContentResponse in each iteration.\n */\nfunction getResponseStream(inputStream) {\n    const reader = inputStream.getReader();\n    const stream = new ReadableStream({\n        start(controller) {\n            let currentText = \"\";\n            return pump();\n            function pump() {\n                return reader\n                    .read()\n                    .then(({ value, done }) => {\n                    if (done) {\n                        if (currentText.trim()) {\n                            controller.error(new GoogleGenerativeAIError(\"Failed to parse stream\"));\n                            return;\n                        }\n                        controller.close();\n                        return;\n                    }\n                    currentText += value;\n                    let match = currentText.match(responseLineRE);\n                    let parsedResponse;\n                    while (match) {\n                        try {\n                            parsedResponse = JSON.parse(match[1]);\n                        }\n                        catch (e) {\n                            controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: \"${match[1]}\"`));\n                            return;\n                        }\n                        controller.enqueue(parsedResponse);\n                        currentText = currentText.substring(match[0].length);\n                        match = currentText.match(responseLineRE);\n                    }\n                    return pump();\n                })\n                    .catch((e) => {\n                    let err = e;\n                    err.stack = e.stack;\n                    if (err.name === \"AbortError\") {\n                        err = new GoogleGenerativeAIAbortError(\"Request aborted when reading from the stream\");\n                    }\n                    else {\n                        err = new GoogleGenerativeAIError(\"Error reading from the stream\");\n                    }\n                    throw err;\n                });\n            }\n        },\n    });\n    return stream;\n}\n/**\n * Aggregates an array of `GenerateContentResponse`s into a single\n * GenerateContentResponse.\n */\nfunction aggregateResponses(responses) {\n    const lastResponse = responses[responses.length - 1];\n    const aggregatedResponse = {\n        promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback,\n    };\n    for (const response of responses) {\n        if (response.candidates) {\n            let candidateIndex = 0;\n            for (const candidate of response.candidates) {\n                if (!aggregatedResponse.candidates) {\n                    aggregatedResponse.candidates = [];\n                }\n                if (!aggregatedResponse.candidates[candidateIndex]) {\n                    aggregatedResponse.candidates[candidateIndex] = {\n                        index: candidateIndex,\n                    };\n                }\n                // Keep overwriting, the last one will be final\n                aggregatedResponse.candidates[candidateIndex].citationMetadata =\n                    candidate.citationMetadata;\n                aggregatedResponse.candidates[candidateIndex].groundingMetadata =\n                    candidate.groundingMetadata;\n                aggregatedResponse.candidates[candidateIndex].finishReason =\n                    candidate.finishReason;\n                aggregatedResponse.candidates[candidateIndex].finishMessage =\n                    candidate.finishMessage;\n                aggregatedResponse.candidates[candidateIndex].safetyRatings =\n                    candidate.safetyRatings;\n                /**\n                 * Candidates should always have content and parts, but this handles\n                 * possible malformed responses.\n                 */\n                if (candidate.content && candidate.content.parts) {\n                    if (!aggregatedResponse.candidates[candidateIndex].content) {\n                        aggregatedResponse.candidates[candidateIndex].content = {\n                            role: candidate.content.role || \"user\",\n                            parts: [],\n                        };\n                    }\n                    const newPart = {};\n                    for (const part of candidate.content.parts) {\n                        if (part.text) {\n                            newPart.text = part.text;\n                        }\n                        if (part.functionCall) {\n                            newPart.functionCall = part.functionCall;\n                        }\n                        if (part.executableCode) {\n                            newPart.executableCode = part.executableCode;\n                        }\n                        if (part.codeExecutionResult) {\n                            newPart.codeExecutionResult = part.codeExecutionResult;\n                        }\n                        if (Object.keys(newPart).length === 0) {\n                            newPart.text = \"\";\n                        }\n                        aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);\n                    }\n                }\n            }\n            candidateIndex++;\n        }\n        if (response.usageMetadata) {\n            aggregatedResponse.usageMetadata = response.usageMetadata;\n        }\n    }\n    return aggregatedResponse;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function generateContentStream(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.STREAM_GENERATE_CONTENT, apiKey, \n    /* stream */ true, JSON.stringify(params), requestOptions);\n    return processStream(response);\n}\nasync function generateContent(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.GENERATE_CONTENT, apiKey, \n    /* stream */ false, JSON.stringify(params), requestOptions);\n    const responseJson = await response.json();\n    const enhancedResponse = addHelpers(responseJson);\n    return {\n        response: enhancedResponse,\n    };\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction formatSystemInstruction(input) {\n    // null or undefined\n    if (input == null) {\n        return undefined;\n    }\n    else if (typeof input === \"string\") {\n        return { role: \"system\", parts: [{ text: input }] };\n    }\n    else if (input.text) {\n        return { role: \"system\", parts: [input] };\n    }\n    else if (input.parts) {\n        if (!input.role) {\n            return { role: \"system\", parts: input.parts };\n        }\n        else {\n            return input;\n        }\n    }\n}\nfunction formatNewContent(request) {\n    let newParts = [];\n    if (typeof request === \"string\") {\n        newParts = [{ text: request }];\n    }\n    else {\n        for (const partOrString of request) {\n            if (typeof partOrString === \"string\") {\n                newParts.push({ text: partOrString });\n            }\n            else {\n                newParts.push(partOrString);\n            }\n        }\n    }\n    return assignRoleToPartsAndValidateSendMessageRequest(newParts);\n}\n/**\n * When multiple Part types (i.e. FunctionResponsePart and TextPart) are\n * passed in a single Part array, we may need to assign different roles to each\n * part. Currently only FunctionResponsePart requires a role other than 'user'.\n * @private\n * @param parts Array of parts to pass to the model\n * @returns Array of content items\n */\nfunction assignRoleToPartsAndValidateSendMessageRequest(parts) {\n    const userContent = { role: \"user\", parts: [] };\n    const functionContent = { role: \"function\", parts: [] };\n    let hasUserContent = false;\n    let hasFunctionContent = false;\n    for (const part of parts) {\n        if (\"functionResponse\" in part) {\n            functionContent.parts.push(part);\n            hasFunctionContent = true;\n        }\n        else {\n            userContent.parts.push(part);\n            hasUserContent = true;\n        }\n    }\n    if (hasUserContent && hasFunctionContent) {\n        throw new GoogleGenerativeAIError(\"Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.\");\n    }\n    if (!hasUserContent && !hasFunctionContent) {\n        throw new GoogleGenerativeAIError(\"No content is provided for sending chat message.\");\n    }\n    if (hasUserContent) {\n        return userContent;\n    }\n    return functionContent;\n}\nfunction formatCountTokensInput(params, modelParams) {\n    var _a;\n    let formattedGenerateContentRequest = {\n        model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,\n        generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,\n        safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,\n        tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,\n        toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,\n        systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,\n        cachedContent: (_a = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a === void 0 ? void 0 : _a.name,\n        contents: [],\n    };\n    const containsGenerateContentRequest = params.generateContentRequest != null;\n    if (params.contents) {\n        if (containsGenerateContentRequest) {\n            throw new GoogleGenerativeAIRequestInputError(\"CountTokensRequest must have one of contents or generateContentRequest, not both.\");\n        }\n        formattedGenerateContentRequest.contents = params.contents;\n    }\n    else if (containsGenerateContentRequest) {\n        formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);\n    }\n    else {\n        // Array or string\n        const content = formatNewContent(params);\n        formattedGenerateContentRequest.contents = [content];\n    }\n    return { generateContentRequest: formattedGenerateContentRequest };\n}\nfunction formatGenerateContentInput(params) {\n    let formattedRequest;\n    if (params.contents) {\n        formattedRequest = params;\n    }\n    else {\n        // Array or string\n        const content = formatNewContent(params);\n        formattedRequest = { contents: [content] };\n    }\n    if (params.systemInstruction) {\n        formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);\n    }\n    return formattedRequest;\n}\nfunction formatEmbedContentInput(params) {\n    if (typeof params === \"string\" || Array.isArray(params)) {\n        const content = formatNewContent(params);\n        return { content };\n    }\n    return params;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// https://ai.google.dev/api/rest/v1beta/Content#part\nconst VALID_PART_FIELDS = [\n    \"text\",\n    \"inlineData\",\n    \"functionCall\",\n    \"functionResponse\",\n    \"executableCode\",\n    \"codeExecutionResult\",\n];\nconst VALID_PARTS_PER_ROLE = {\n    user: [\"text\", \"inlineData\"],\n    function: [\"functionResponse\"],\n    model: [\"text\", \"functionCall\", \"executableCode\", \"codeExecutionResult\"],\n    // System instructions shouldn't be in history anyway.\n    system: [\"text\"],\n};\nfunction validateChatHistory(history) {\n    let prevContent = false;\n    for (const currContent of history) {\n        const { role, parts } = currContent;\n        if (!prevContent && role !== \"user\") {\n            throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);\n        }\n        if (!POSSIBLE_ROLES.includes(role)) {\n            throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);\n        }\n        if (!Array.isArray(parts)) {\n            throw new GoogleGenerativeAIError(\"Content should have 'parts' property with an array of Parts\");\n        }\n        if (parts.length === 0) {\n            throw new GoogleGenerativeAIError(\"Each Content should have at least one part\");\n        }\n        const countFields = {\n            text: 0,\n            inlineData: 0,\n            functionCall: 0,\n            functionResponse: 0,\n            fileData: 0,\n            executableCode: 0,\n            codeExecutionResult: 0,\n        };\n        for (const part of parts) {\n            for (const key of VALID_PART_FIELDS) {\n                if (key in part) {\n                    countFields[key] += 1;\n                }\n            }\n        }\n        const validParts = VALID_PARTS_PER_ROLE[role];\n        for (const key of VALID_PART_FIELDS) {\n            if (!validParts.includes(key) && countFields[key] > 0) {\n                throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);\n            }\n        }\n        prevContent = true;\n    }\n}\n/**\n * Returns true if the response is valid (could be appended to the history), flase otherwise.\n */\nfunction isValidResponse(response) {\n    var _a;\n    if (response.candidates === undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts) {\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n        if (part.text !== undefined && part.text === \"\") {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do not log a message for this error.\n */\nconst SILENT_ERROR = \"SILENT_ERROR\";\n/**\n * ChatSession class that enables sending chat messages and stores\n * history of sent and received messages so far.\n *\n * @public\n */\nclass ChatSession {\n    constructor(apiKey, model, params, _requestOptions = {}) {\n        this.model = model;\n        this.params = params;\n        this._requestOptions = _requestOptions;\n        this._history = [];\n        this._sendPromise = Promise.resolve();\n        this._apiKey = apiKey;\n        if (params === null || params === void 0 ? void 0 : params.history) {\n            validateChatHistory(params.history);\n            this._history = params.history;\n        }\n    }\n    /**\n     * Gets the chat history so far. Blocked prompts are not added to history.\n     * Blocked candidates are not added to history, nor are the prompts that\n     * generated them.\n     */\n    async getHistory() {\n        await this._sendPromise;\n        return this._history;\n    }\n    /**\n     * Sends a chat message and receives a non-streaming\n     * {@link GenerateContentResult}.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async sendMessage(request, requestOptions = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        await this._sendPromise;\n        const newContent = formatNewContent(request);\n        const generateContentRequest = {\n            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,\n            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,\n            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,\n            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,\n            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,\n            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,\n            contents: [...this._history, newContent],\n        };\n        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        let finalResult;\n        // Add onto the chain.\n        this._sendPromise = this._sendPromise\n            .then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions))\n            .then((result) => {\n            var _a;\n            if (isValidResponse(result.response)) {\n                this._history.push(newContent);\n                const responseContent = Object.assign({ parts: [], \n                    // Response seems to come back without a role set.\n                    role: \"model\" }, (_a = result.response.candidates) === null || _a === void 0 ? void 0 : _a[0].content);\n                this._history.push(responseContent);\n            }\n            else {\n                const blockErrorMessage = formatBlockErrorMessage(result.response);\n                if (blockErrorMessage) {\n                    console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);\n                }\n            }\n            finalResult = result;\n        })\n            .catch((e) => {\n            // Resets _sendPromise to avoid subsequent calls failing and throw error.\n            this._sendPromise = Promise.resolve();\n            throw e;\n        });\n        await this._sendPromise;\n        return finalResult;\n    }\n    /**\n     * Sends a chat message and receives the response as a\n     * {@link GenerateContentStreamResult} containing an iterable stream\n     * and a response promise.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async sendMessageStream(request, requestOptions = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        await this._sendPromise;\n        const newContent = formatNewContent(request);\n        const generateContentRequest = {\n            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,\n            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,\n            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,\n            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,\n            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,\n            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,\n            contents: [...this._history, newContent],\n        };\n        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);\n        // Add onto the chain.\n        this._sendPromise = this._sendPromise\n            .then(() => streamPromise)\n            // This must be handled to avoid unhandled rejection, but jump\n            // to the final catch block with a label to not log this error.\n            .catch((_ignored) => {\n            throw new Error(SILENT_ERROR);\n        })\n            .then((streamResult) => streamResult.response)\n            .then((response) => {\n            if (isValidResponse(response)) {\n                this._history.push(newContent);\n                const responseContent = Object.assign({}, response.candidates[0].content);\n                // Response seems to come back without a role set.\n                if (!responseContent.role) {\n                    responseContent.role = \"model\";\n                }\n                this._history.push(responseContent);\n            }\n            else {\n                const blockErrorMessage = formatBlockErrorMessage(response);\n                if (blockErrorMessage) {\n                    console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);\n                }\n            }\n        })\n            .catch((e) => {\n            // Errors in streamPromise are already catchable by the user as\n            // streamPromise is returned.\n            // Avoid duplicating the error message in logs.\n            if (e.message !== SILENT_ERROR) {\n                // Users do not have access to _sendPromise to catch errors\n                // downstream from streamPromise, so they should not throw.\n                console.error(e);\n            }\n        });\n        return streamPromise;\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function countTokens(apiKey, model, params, singleRequestOptions) {\n    const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);\n    return response.json();\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function embedContent(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);\n    return response.json();\n}\nasync function batchEmbedContents(apiKey, model, params, requestOptions) {\n    const requestsWithModel = params.requests.map((request) => {\n        return Object.assign(Object.assign({}, request), { model });\n    });\n    const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);\n    return response.json();\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class for generative model APIs.\n * @public\n */\nclass GenerativeModel {\n    constructor(apiKey, modelParams, _requestOptions = {}) {\n        this.apiKey = apiKey;\n        this._requestOptions = _requestOptions;\n        if (modelParams.model.includes(\"/\")) {\n            // Models may be named \"models/model-name\" or \"tunedModels/model-name\"\n            this.model = modelParams.model;\n        }\n        else {\n            // If path is not included, assume it's a non-tuned model.\n            this.model = `models/${modelParams.model}`;\n        }\n        this.generationConfig = modelParams.generationConfig || {};\n        this.safetySettings = modelParams.safetySettings || [];\n        this.tools = modelParams.tools;\n        this.toolConfig = modelParams.toolConfig;\n        this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);\n        this.cachedContent = modelParams.cachedContent;\n    }\n    /**\n     * Makes a single non-streaming call to the model\n     * and returns an object containing a single {@link GenerateContentResponse}.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async generateContent(request, requestOptions = {}) {\n        var _a;\n        const formattedParams = formatGenerateContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);\n    }\n    /**\n     * Makes a single streaming call to the model and returns an object\n     * containing an iterable stream that iterates over all chunks in the\n     * streaming response as well as a promise that returns the final\n     * aggregated response.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async generateContentStream(request, requestOptions = {}) {\n        var _a;\n        const formattedParams = formatGenerateContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);\n    }\n    /**\n     * Gets a new {@link ChatSession} instance which can be used for\n     * multi-turn chats.\n     */\n    startChat(startChatParams) {\n        var _a;\n        return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, startChatParams), this._requestOptions);\n    }\n    /**\n     * Counts the tokens in the provided request.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async countTokens(request, requestOptions = {}) {\n        const formattedParams = formatCountTokensInput(request, {\n            model: this.model,\n            generationConfig: this.generationConfig,\n            safetySettings: this.safetySettings,\n            tools: this.tools,\n            toolConfig: this.toolConfig,\n            systemInstruction: this.systemInstruction,\n            cachedContent: this.cachedContent,\n        });\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);\n    }\n    /**\n     * Embeds the provided content.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async embedContent(request, requestOptions = {}) {\n        const formattedParams = formatEmbedContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);\n    }\n    /**\n     * Embeds an array of {@link EmbedContentRequest}s.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Top-level class for this SDK\n * @public\n */\nclass GoogleGenerativeAI {\n    constructor(apiKey) {\n        this.apiKey = apiKey;\n    }\n    /**\n     * Gets a {@link GenerativeModel} instance for the provided model name.\n     */\n    getGenerativeModel(modelParams, requestOptions) {\n        if (!modelParams.model) {\n            throw new GoogleGenerativeAIError(`Must provide a model name. ` +\n                `Example: genai.getGenerativeModel({ model: 'my-model-name' })`);\n        }\n        return new GenerativeModel(this.apiKey, modelParams, requestOptions);\n    }\n    /**\n     * Creates a {@link GenerativeModel} instance from provided content cache.\n     */\n    getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {\n        if (!cachedContent.name) {\n            throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `name` field.\");\n        }\n        if (!cachedContent.model) {\n            throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `model` field.\");\n        }\n        /**\n         * Not checking tools and toolConfig for now as it would require a deep\n         * equality comparison and isn't likely to be a common case.\n         */\n        const disallowedDuplicates = [\"model\", \"systemInstruction\"];\n        for (const key of disallowedDuplicates) {\n            if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) &&\n                cachedContent[key] &&\n                (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {\n                if (key === \"model\") {\n                    const modelParamsComp = modelParams.model.startsWith(\"models/\")\n                        ? modelParams.model.replace(\"models/\", \"\")\n                        : modelParams.model;\n                    const cachedContentComp = cachedContent.model.startsWith(\"models/\")\n                        ? cachedContent.model.replace(\"models/\", \"\")\n                        : cachedContent.model;\n                    if (modelParamsComp === cachedContentComp) {\n                        continue;\n                    }\n                }\n                throw new GoogleGenerativeAIRequestInputError(`Different value for \"${key}\" specified in modelParams` +\n                    ` (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);\n            }\n        }\n        const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });\n        return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);\n    }\n}\n\nexport { BlockReason, ChatSession, DynamicRetrievalMode, ExecutableCodeLanguage, FinishReason, FunctionCallingMode, GenerativeModel, GoogleGenerativeAI, GoogleGenerativeAIAbortError, GoogleGenerativeAIError, GoogleGenerativeAIFetchError, GoogleGenerativeAIRequestInputError, GoogleGenerativeAIResponseError, HarmBlockThreshold, HarmCategory, HarmProbability, Outcome, POSSIBLE_ROLES, SchemaType, TaskType };\n//# sourceMappingURL=index.mjs.map\n","// src/background/config.ts\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ErrorFactory, ErrorLogger, withErrorHandling, withTimeout } from '../utils/errors';\n/**\n * Valida o formato da API key do Google Gemini\n * @param apiKey - A API key para validar\n * @throws {ValidationError} Se a API key for invlida\n */\nfunction validateApiKey(apiKey) {\n    if (!apiKey || typeof apiKey !== 'string') {\n        throw ErrorFactory.validationFailure('apiKey', apiKey, 'API key deve ser uma string no vazia');\n    }\n    const trimmedKey = apiKey.trim();\n    if (trimmedKey.length === 0) {\n        throw ErrorFactory.validationFailure('apiKey', apiKey, 'API key no pode estar vazia');\n    }\n    if (!trimmedKey.startsWith('AIza')) {\n        throw ErrorFactory.invalidApiKey(trimmedKey);\n    }\n    if (trimmedKey.length < 35) {\n        throw ErrorFactory.invalidApiKey(trimmedKey);\n    }\n}\n/**\n * Obtm a API key do Gemini do storage seguro\n * @returns Promise com a API key ou null se no configurada\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nexport function getGeminiApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield chrome.storage.sync.get(['geminiApiKey']);\n                return result.geminiApiKey || null;\n            }), 5000, 'getGeminiApiKey');\n        }), (error) => ErrorFactory.storageFailure('get', error));\n    });\n}\n/**\n * Salva a API key do Gemini no storage seguro\n * @param apiKey - A API key para salvar\n * @throws {ValidationError} Se a API key for invlida\n * @throws {StorageError} Se houver erro ao salvar no storage\n */\nexport function setGeminiApiKey(apiKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Valida a API key antes de salvar\n        validateApiKey(apiKey);\n        yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                yield chrome.storage.sync.set({\n                    geminiApiKey: apiKey.trim(),\n                    lastUpdated: Date.now()\n                });\n            }), 5000, 'setGeminiApiKey');\n        }), (error) => ErrorFactory.storageFailure('set', error));\n    });\n}\n/**\n * Remove a API key do storage\n * @throws {StorageError} Se houver erro ao remover do storage\n */\nexport function clearGeminiApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                yield chrome.storage.sync.remove(['geminiApiKey', 'lastUpdated']);\n            }), 5000, 'clearGeminiApiKey');\n        }), (error) => ErrorFactory.storageFailure('remove', error));\n    });\n}\n/**\n * Verifica se a API key est configurada\n * @returns Promise<boolean> - true se a API key est configurada\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nexport function isApiKeyConfigured() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const apiKey = yield getGeminiApiKey();\n            return apiKey !== null && apiKey.length > 0;\n        }\n        catch (error) {\n            // Se houver erro ao acessar storage, assumimos que no est configurada\n            ErrorLogger.log(error);\n            return false;\n        }\n    });\n}\n/**\n * Obtm configuraes completas da extenso\n * @returns Promise<ExtensionConfig> - Configuraes da extenso\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nexport function getExtensionConfig() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield chrome.storage.sync.get(['geminiApiKey', 'lastUpdated']);\n                return {\n                    geminiApiKey: result.geminiApiKey || undefined,\n                    lastUpdated: result.lastUpdated || undefined\n                };\n            }), 5000, 'getExtensionConfig');\n        }), (error) => ErrorFactory.storageFailure('get', error));\n    });\n}\n","// src/utils/cache.ts - Sistema de cache inteligente para performance\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ErrorFactory, ErrorLogger, withErrorHandling } from './errors';\n/**\n * Estratgias de eviction do cache\n */\nexport var EvictionStrategy;\n(function (EvictionStrategy) {\n    EvictionStrategy[\"LRU\"] = \"lru\";\n    EvictionStrategy[\"LFU\"] = \"lfu\";\n    EvictionStrategy[\"TTL\"] = \"ttl\";\n})(EvictionStrategy || (EvictionStrategy = {}));\n/**\n * Sistema de cache inteligente com mltiplas estratgias\n */\nexport class IntelligentCache {\n    constructor(config = {}) {\n        this.cache = new Map();\n        this.currentSize = 0;\n        this.config = Object.assign({ maxSize: 10 * 1024 * 1024, maxItems: 1000, defaultTtl: 30 * 60 * 1000, cleanupInterval: 5 * 60 * 1000 }, config);\n        this.startCleanupTimer();\n    }\n    /**\n     * Adiciona item ao cache\n     */\n    set(key, data, ttl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n                const now = Date.now();\n                const itemTtl = ttl || this.config.defaultTtl;\n                const size = this.estimateSize(data);\n                // Remove item existente se houver\n                if (this.cache.has(key)) {\n                    this.remove(key);\n                }\n                // Verifica se precisa fazer eviction\n                yield this.ensureSpace(size);\n                const item = {\n                    data,\n                    timestamp: now,\n                    ttl: itemTtl,\n                    accessCount: 0,\n                    lastAccessed: now,\n                    size,\n                };\n                this.cache.set(key, item);\n                this.currentSize += size;\n                // Persiste no storage se necessrio\n                yield this.persistToStorage(key, item);\n            }), (error) => ErrorFactory.storageFailure('cache_set', error));\n        });\n    }\n    /**\n     * Recupera item do cache\n     */\n    get(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n                let item = this.cache.get(key);\n                // Se no est na memria, tenta carregar do storage\n                if (!item) {\n                    const storageItem = yield this.loadFromStorage(key);\n                    if (storageItem) {\n                        item = storageItem;\n                        this.cache.set(key, item);\n                        this.currentSize += item.size || 0;\n                    }\n                }\n                if (!item) {\n                    return null;\n                }\n                // Verifica se expirou\n                const now = Date.now();\n                if (now - item.timestamp > item.ttl) {\n                    this.remove(key);\n                    return null;\n                }\n                // Atualiza estatsticas de acesso\n                item.accessCount++;\n                item.lastAccessed = now;\n                return item.data;\n            }), (error) => ErrorFactory.storageFailure('cache_get', error.message || 'Cache get failed'));\n        });\n    }\n    /**\n     * Remove item do cache\n     */\n    remove(key) {\n        const item = this.cache.get(key);\n        if (item) {\n            this.cache.delete(key);\n            this.currentSize -= item.size || 0;\n            this.removeFromStorage(key);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Limpa todo o cache\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.cache.clear();\n            this.currentSize = 0;\n            yield this.clearStorage();\n        });\n    }\n    /**\n     * Verifica se item existe e no expirou\n     */\n    has(key) {\n        const item = this.cache.get(key);\n        if (!item)\n            return false;\n        const now = Date.now();\n        if (now - item.timestamp > item.ttl) {\n            this.remove(key);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Obtm estatsticas do cache\n     */\n    getStats() {\n        const items = Array.from(this.cache.values());\n        const totalAccess = items.reduce((sum, item) => sum + item.accessCount, 0);\n        const totalPossibleAccess = items.length * Math.max(...items.map(i => i.accessCount), 1);\n        return {\n            size: this.currentSize,\n            itemCount: this.cache.size,\n            hitRate: totalPossibleAccess > 0 ? totalAccess / totalPossibleAccess : 0,\n            memoryUsage: this.currentSize / this.config.maxSize,\n            oldestItem: Math.min(...items.map(i => i.timestamp), Date.now()),\n            newestItem: Math.max(...items.map(i => i.timestamp), 0),\n        };\n    }\n    /**\n     * Fora limpeza do cache\n     */\n    cleanup() {\n        const now = Date.now();\n        const keysToRemove = [];\n        for (const [key, item] of this.cache.entries()) {\n            if (now - item.timestamp > item.ttl) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.forEach(key => this.remove(key));\n    }\n    /**\n     * Garante que h espao suficiente no cache\n     */\n    ensureSpace(requiredSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Se j tem espao, no faz nada\n            if (this.currentSize + requiredSize <= this.config.maxSize &&\n                this.cache.size < this.config.maxItems) {\n                return;\n            }\n            // Executa estratgias de eviction\n            yield this.evictItems(requiredSize);\n        });\n    }\n    /**\n     * Remove itens usando estratgias de eviction\n     */\n    evictItems(requiredSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const items = Array.from(this.cache.entries());\n            // Ordena por estratgia LRU (menos recentemente usado)\n            items.sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);\n            let freedSpace = 0;\n            for (const [key] of items) {\n                if (freedSpace >= requiredSize && this.cache.size < this.config.maxItems) {\n                    break;\n                }\n                const item = this.cache.get(key);\n                if (item) {\n                    freedSpace += item.size || 0;\n                    this.remove(key);\n                }\n            }\n        });\n    }\n    /**\n     * Estima o tamanho de um objeto em bytes\n     */\n    estimateSize(data) {\n        try {\n            return new Blob([JSON.stringify(data)]).size;\n        }\n        catch (_a) {\n            // Fallback para estimativa simples\n            return JSON.stringify(data).length * 2; // UTF-16\n        }\n    }\n    /**\n     * Persiste item no storage\n     */\n    persistToStorage(key, item) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const storageKey = `cache_${key}`;\n                yield chrome.storage.local.set({ [storageKey]: item });\n            }\n            catch (error) {\n                // Falha silenciosa - cache funciona apenas na memria\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_persist', error));\n            }\n        });\n    }\n    /**\n     * Carrega item do storage\n     */\n    loadFromStorage(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const storageKey = `cache_${key}`;\n                const result = yield chrome.storage.local.get([storageKey]);\n                return result[storageKey] || null;\n            }\n            catch (error) {\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_load', error));\n                return null;\n            }\n        });\n    }\n    /**\n     * Remove item do storage\n     */\n    removeFromStorage(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const storageKey = `cache_${key}`;\n                yield chrome.storage.local.remove([storageKey]);\n            }\n            catch (error) {\n                // Falha silenciosa\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_remove', error));\n            }\n        });\n    }\n    /**\n     * Limpa todo o storage do cache\n     */\n    clearStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield chrome.storage.local.get(null);\n                const cacheKeys = Object.keys(result).filter(key => key.startsWith('cache_'));\n                if (cacheKeys.length > 0) {\n                    yield chrome.storage.local.remove(cacheKeys);\n                }\n            }\n            catch (error) {\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_clear', error));\n            }\n        });\n    }\n    /**\n     * Inicia timer de limpeza automtica\n     */\n    startCleanupTimer() {\n        this.cleanupTimer = setInterval(() => {\n            this.cleanup();\n        }, this.config.cleanupInterval);\n    }\n    /**\n     * Para timer de limpeza\n     */\n    destroy() {\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n}\n/**\n * Cache especfico para respostas da IA\n */\nexport class AIResponseCache extends IntelligentCache {\n    constructor() {\n        super({\n            maxSize: 5 * 1024 * 1024, // 5MB para respostas da IA\n            maxItems: 100,\n            defaultTtl: 60 * 60 * 1000, // 1 hora\n        });\n    }\n    /**\n     * Gera chave de cache baseada no contexto e prompt\n     */\n    generateKey(context, prompt) {\n        const combined = `${context}_${prompt}`;\n        return this.hashString(combined);\n    }\n    /**\n     * Hash simples para gerar chaves\n     */\n    hashString(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32-bit integer\n        }\n        return Math.abs(hash).toString(36);\n    }\n}\n/**\n * Cache para contextos de pgina\n */\nexport class PageContextCache extends IntelligentCache {\n    constructor() {\n        super({\n            maxSize: 2 * 1024 * 1024, // 2MB para contextos\n            maxItems: 50,\n            defaultTtl: 10 * 60 * 1000, // 10 minutos\n        });\n    }\n    /**\n     * Gera chave baseada na URL e hash do contedo\n     */\n    generateKey(url, contentHash) {\n        return `${url}_${contentHash}`;\n    }\n}\n// Instncias globais dos caches\nexport const aiResponseCache = new AIResponseCache();\nexport const pageContextCache = new PageContextCache();\n","// src/utils/errors.ts - Sistema de tratamento de erros personalizado\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Classe base para erros da extenso\n */\nexport class ExtensionError extends Error {\n    constructor(message, context) {\n        super(message);\n        this.name = this.constructor.name;\n        this.timestamp = Date.now();\n        this.context = context;\n        // Mantm o stack trace correto\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    /**\n     * Converte o erro para um objeto serializvel\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            code: this.code,\n            message: this.message,\n            userMessage: this.userMessage,\n            timestamp: this.timestamp,\n            context: this.context,\n            stack: this.stack,\n        };\n    }\n}\n/**\n * Erro relacionado  configurao da API key\n */\nexport class ApiKeyError extends ExtensionError {\n    constructor(message, userMessage, context) {\n        super(message, context);\n        this.userMessage = userMessage;\n        this.code = 'API_KEY_ERROR';\n    }\n}\n/**\n * Erro de comunicao com a API do Gemini\n */\nexport class GeminiApiError extends ExtensionError {\n    constructor(message, userMessage, statusCode, context) {\n        super(message, Object.assign(Object.assign({}, context), { statusCode }));\n        this.userMessage = userMessage;\n        this.statusCode = statusCode;\n        this.code = 'GEMINI_API_ERROR';\n    }\n}\n/**\n * Erro de storage do Chrome\n */\nexport class StorageError extends ExtensionError {\n    constructor(message, userMessage, context) {\n        super(message, context);\n        this.userMessage = userMessage;\n        this.code = 'STORAGE_ERROR';\n    }\n}\n/**\n * Erro de captura de pgina\n */\nexport class PageCaptureError extends ExtensionError {\n    constructor(message, userMessage, context) {\n        super(message, context);\n        this.userMessage = userMessage;\n        this.code = 'PAGE_CAPTURE_ERROR';\n    }\n}\n/**\n * Erro de validao de dados\n */\nexport class ValidationError extends ExtensionError {\n    constructor(message, userMessage, field, context) {\n        super(message, Object.assign(Object.assign({}, context), { field }));\n        this.userMessage = userMessage;\n        this.field = field;\n        this.code = 'VALIDATION_ERROR';\n    }\n}\n/**\n * Erro de timeout\n */\nexport class TimeoutError extends ExtensionError {\n    constructor(message, userMessage, timeoutMs, context) {\n        super(message, Object.assign(Object.assign({}, context), { timeoutMs }));\n        this.userMessage = userMessage;\n        this.timeoutMs = timeoutMs;\n        this.code = 'TIMEOUT_ERROR';\n    }\n}\n/**\n * Utilitrio para criar erros baseados em diferentes tipos de falha\n */\nexport class ErrorFactory {\n    static apiKeyNotConfigured() {\n        return new ApiKeyError('Gemini API key is not configured', 'API key do Gemini no configurada. Por favor, configure nas opes da extenso.', { action: 'configure_api_key' });\n    }\n    static invalidApiKey(key) {\n        return new ApiKeyError(`Invalid API key format: ${key.substring(0, 8)}...`, 'Formato de API key invlido. Verifique se voc copiou a chave corretamente.', { keyPrefix: key.substring(0, 8) });\n    }\n    static geminiApiFailure(error, statusCode) {\n        const message = (error === null || error === void 0 ? void 0 : error.message) || 'Unknown Gemini API error';\n        let userMessage = 'Erro ao comunicar com a IA. Tente novamente em alguns momentos.';\n        if (statusCode === 429) {\n            userMessage = 'Muitas requisies. Aguarde um momento antes de tentar novamente.';\n        }\n        else if (statusCode === 401) {\n            userMessage = 'API key invlida. Verifique sua configurao.';\n        }\n        else if (statusCode === 403) {\n            userMessage = 'Acesso negado. Verifique se sua API key tem as permisses necessrias.';\n        }\n        return new GeminiApiError(message, userMessage, statusCode, { originalError: error });\n    }\n    static storageFailure(operation, error) {\n        return new StorageError(`Storage ${operation} failed: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`, 'Erro ao acessar configuraes. Tente recarregar a extenso.', { operation, originalError: error });\n    }\n    static pageCaptureFailure(error) {\n        return new PageCaptureError(`Failed to capture page: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`, 'No foi possvel capturar a pgina. Verifique se a pgina est carregada completamente.', { originalError: error });\n    }\n    static validationFailure(field, value, reason) {\n        return new ValidationError(`Validation failed for ${field}: ${reason}`, `Valor invlido para ${field}: ${reason}`, field, { value, reason });\n    }\n    static timeoutFailure(operation, timeoutMs) {\n        return new TimeoutError(`Operation ${operation} timed out after ${timeoutMs}ms`, 'Operao demorou muito para responder. Tente novamente.', timeoutMs, { operation });\n    }\n}\n/**\n * Logger centralizado para erros\n */\nexport class ErrorLogger {\n    /**\n     * Registra um erro no log\n     */\n    static log(error) {\n        this.logs.push({ error, timestamp: Date.now() });\n        // Mantm apenas os ltimos MAX_LOGS\n        if (this.logs.length > this.MAX_LOGS) {\n            this.logs = this.logs.slice(-this.MAX_LOGS);\n        }\n        // Log no console para desenvolvimento\n        console.error(`[${error.code}] ${error.message}`, {\n            userMessage: error.userMessage,\n            context: error.context,\n            stack: error.stack,\n        });\n    }\n    /**\n     * Obtm todos os logs de erro\n     */\n    static getLogs() {\n        return [...this.logs];\n    }\n    /**\n     * Limpa todos os logs\n     */\n    static clearLogs() {\n        this.logs = [];\n    }\n    /**\n     * Obtm estatsticas dos erros\n     */\n    static getStats() {\n        const stats = {};\n        this.logs.forEach(({ error }) => {\n            stats[error.code] = (stats[error.code] || 0) + 1;\n        });\n        return stats;\n    }\n}\nErrorLogger.MAX_LOGS = 100;\nErrorLogger.logs = [];\n/**\n * Wrapper para operaes assncronas com tratamento de erro\n */\nexport function withErrorHandling(operation, errorFactory) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            return yield operation();\n        }\n        catch (error) {\n            // Se j  um ExtensionError (como TimeoutError), preserva o tipo original\n            if (error instanceof ExtensionError) {\n                ErrorLogger.log(error);\n                throw error;\n            }\n            const extensionError = errorFactory(error);\n            ErrorLogger.log(extensionError);\n            throw extensionError;\n        }\n    });\n}\n/**\n * Wrapper para operaes com timeout\n */\nexport function withTimeout(operation, timeoutMs, operationName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const timer = setTimeout(() => {\n                const error = ErrorFactory.timeoutFailure(operationName, timeoutMs);\n                ErrorLogger.log(error);\n                reject(error);\n            }, timeoutMs);\n            operation()\n                .then(resolve)\n                .catch(reject)\n                .finally(() => clearTimeout(timer));\n        });\n    });\n}\n","// src/utils/fullPageCapture.ts - Sistema de Captura de Pgina Completa\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Captura as dimenses completas da pgina\n */\nexport function getPageDimensions(tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const results = yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: () => {\n                return {\n                    width: Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth),\n                    height: Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight),\n                    viewportWidth: window.innerWidth,\n                    viewportHeight: window.innerHeight,\n                    scrollWidth: document.documentElement.scrollWidth,\n                    scrollHeight: document.documentElement.scrollHeight\n                };\n            }\n        });\n        if (!((_a = results[0]) === null || _a === void 0 ? void 0 : _a.result)) {\n            throw new Error('Falha ao obter dimenses da pgina');\n        }\n        return results[0].result;\n    });\n}\n/**\n * Captura pgina completa usando abordagem mais simples e rpida\n * Minimiza o tempo de scroll para reduzir impacto visual\n */\nfunction captureFullPageWithoutScroll(tabId, windowId, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        // 1. Salvar posio atual do usurio\n        const originalPosition = yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: () => ({ x: window.scrollX, y: window.scrollY })\n        });\n        const originalScroll = ((_a = originalPosition[0]) === null || _a === void 0 ? void 0 : _a.result) || { x: 0, y: 0 };\n        // 2. Obter dimenses da pgina\n        const dimensions = yield getPageDimensions(tabId);\n        // 3. Calcular segmentos\n        const maxHeight = options.maxHeight || 8000;\n        const effectiveHeight = Math.min(dimensions.height, maxHeight);\n        const viewportHeight = dimensions.viewportHeight;\n        const segmentCount = Math.ceil(effectiveHeight / viewportHeight);\n        console.log(`[FullPageCapture] Capturando ${segmentCount} segmentos rapidamente...`);\n        const screenshots = [];\n        // 4. Capturar cada segmento respeitando rate limits do Chrome\n        for (let i = 0; i < segmentCount; i++) {\n            const yPosition = i * viewportHeight;\n            // Scroll instantneo para a posio\n            yield chrome.scripting.executeScript({\n                target: { tabId },\n                func: (y) => {\n                    window.scrollTo({\n                        top: y,\n                        left: 0,\n                        behavior: 'instant'\n                    });\n                },\n                args: [yPosition]\n            });\n            // Aguardar renderizao + rate limit (aumentado para evitar quota)\n            const waitTime = Math.max(200, options.waitTime || 200);\n            yield new Promise(resolve => setTimeout(resolve, waitTime));\n            try {\n                // Capturar screenshot com retry em caso de rate limit\n                const screenshot = yield chrome.tabs.captureVisibleTab(windowId, {\n                    format: options.format || 'jpeg',\n                    quality: options.quality || 70\n                });\n                if (!screenshot) {\n                    throw new Error(`Screenshot vazio para segmento ${i + 1}`);\n                }\n                screenshots.push(screenshot);\n                console.log(`[FullPageCapture] Segmento ${i + 1}/${segmentCount} capturado`);\n            }\n            catch (error) {\n                if (((_b = error === null || error === void 0 ? void 0 : error.message) === null || _b === void 0 ? void 0 : _b.includes('quota')) || ((_c = error === null || error === void 0 ? void 0 : error.message) === null || _c === void 0 ? void 0 : _c.includes('rate'))) {\n                    console.warn(`[FullPageCapture] Rate limit atingido, aguardando 1s...`);\n                    yield new Promise(resolve => setTimeout(resolve, 1000));\n                    // Retry uma vez\n                    try {\n                        const screenshot = yield chrome.tabs.captureVisibleTab(windowId, {\n                            format: options.format || 'jpeg',\n                            quality: options.quality || 70\n                        });\n                        if (!screenshot) {\n                            throw new Error(`Screenshot vazio para segmento ${i + 1} (retry)`);\n                        }\n                        screenshots.push(screenshot);\n                        console.log(`[FullPageCapture] Segmento ${i + 1}/${segmentCount} capturado (retry)`);\n                    }\n                    catch (retryError) {\n                        console.error(`[FullPageCapture] Falha no retry do segmento ${i + 1}:`, retryError);\n                        throw new Error(`Falha na captura do segmento ${i + 1}: ${retryError}`);\n                    }\n                }\n                else {\n                    console.error(`[FullPageCapture] Erro no segmento ${i + 1}:`, error);\n                    throw error;\n                }\n            }\n        }\n        // 5. Restaurar posio original IMEDIATAMENTE\n        yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: (pos) => {\n                window.scrollTo({\n                    top: pos.y,\n                    left: pos.x,\n                    behavior: 'instant'\n                });\n            },\n            args: [originalScroll]\n        });\n        console.log('[FullPageCapture] Posio original restaurada');\n        return screenshots;\n    });\n}\n/**\n * Une mltiplos screenshots usando OffscreenCanvas (funciona em background)\n */\nfunction stitchScreenshots(screenshots, dimensions, viewportHeight) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Usar OffscreenCanvas para funcionar em background script\n        const canvas = new OffscreenCanvas(dimensions.viewportWidth, Math.min(dimensions.height, screenshots.length * viewportHeight));\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('No foi possvel criar contexto do OffscreenCanvas');\n        }\n        // Carregar e desenhar todas as imagens\n        for (let i = 0; i < screenshots.length; i++) {\n            const screenshot = screenshots[i];\n            const yPosition = i * viewportHeight;\n            // Converter base64 para ImageBitmap\n            const response = yield fetch(screenshot);\n            const blob = yield response.blob();\n            const imageBitmap = yield createImageBitmap(blob);\n            // Desenhar no canvas\n            ctx.drawImage(imageBitmap, 0, yPosition);\n            // Limpar memria\n            imageBitmap.close();\n        }\n        // Converter para blob e depois para data URL\n        const blob = yield canvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = () => resolve(reader.result);\n            reader.onerror = () => reject(new Error('Erro ao converter blob para data URL'));\n            reader.readAsDataURL(blob);\n        });\n    });\n}\n/**\n * Extrai contexto HTML e texto da pgina completa\n */\nfunction extractFullPageContext(tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const results = yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: () => {\n                // Funo para extrair contedo relevante\n                const extractContent = () => {\n                    // Priorizar elementos principais de contedo\n                    const mainContentElement = document.querySelector('main') ||\n                        document.querySelector('article') ||\n                        document.querySelector('[role=\"main\"]') ||\n                        document.querySelector('.content') ||\n                        document.querySelector('#content') ||\n                        document.querySelector('ytd-two-column-browse-results-renderer') || // YouTube\n                        document.body;\n                    const bodyClone = mainContentElement.cloneNode(true);\n                    // Remover elementos desnecessrios\n                    const elementsToRemove = [\n                        'script', 'style', 'svg', 'noscript', 'nav', 'footer',\n                        'aside', '#secondary', '.ads', '.advertisement',\n                        '[data-ad]', '.sidebar', '.menu'\n                    ];\n                    elementsToRemove.forEach(selector => {\n                        bodyClone.querySelectorAll(selector).forEach(el => el.remove());\n                    });\n                    // Extrair texto de elementos importantes\n                    const importantSelectors = [\n                        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n                        'p', 'article', 'section',\n                        '.title', '.heading', '.description',\n                        '[data-testid*=\"title\"]', '[data-testid*=\"description\"]'\n                    ];\n                    let structuredText = '';\n                    importantSelectors.forEach(selector => {\n                        const elements = bodyClone.querySelectorAll(selector);\n                        elements.forEach(el => {\n                            var _a;\n                            const text = (_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim();\n                            if (text && text.length > 10) {\n                                structuredText += `${selector.toUpperCase()}: ${text}\\n`;\n                            }\n                        });\n                    });\n                    return {\n                        title: document.title,\n                        htmlContent: bodyClone.innerHTML,\n                        textContent: bodyClone.innerText,\n                        structuredText: structuredText,\n                        url: window.location.href\n                    };\n                };\n                return extractContent();\n            }\n        });\n        if (!((_a = results[0]) === null || _a === void 0 ? void 0 : _a.result)) {\n            throw new Error('Falha ao extrair contexto da pgina');\n        }\n        const result = results[0].result;\n        return {\n            htmlContext: result.htmlContent,\n            textContext: result.structuredText || result.textContent,\n            title: result.title\n        };\n    });\n}\n/**\n * Funo principal para capturar pgina completa SEM scroll visvel\n */\nexport function captureFullPage(tabId_1, windowId_1) {\n    return __awaiter(this, arguments, void 0, function* (tabId, windowId, options = {}) {\n        const startTime = Date.now();\n        try {\n            // 1. Obter dimenses da pgina\n            console.log('[FullPageCapture] Obtendo dimenses da pgina...');\n            const dimensions = yield getPageDimensions(tabId);\n            // 2. Calcular quantos segmentos precisamos\n            const maxHeight = options.maxHeight || 8000;\n            const effectiveHeight = Math.min(dimensions.height, maxHeight);\n            const viewportHeight = dimensions.viewportHeight;\n            const segmentCount = Math.ceil(effectiveHeight / viewportHeight);\n            console.log(`[FullPageCapture] Pgina: ${dimensions.width}x${dimensions.height}px`);\n            console.log(`[FullPageCapture] Capturando ${segmentCount} segmentos SEM scroll visvel...`);\n            // 3. Capturar todos os segmentos sem afetar o usurio\n            const screenshots = yield captureFullPageWithoutScroll(tabId, windowId, options);\n            // 4. Unir screenshots\n            console.log('[FullPageCapture] Unindo screenshots...');\n            const fullScreenshot = yield stitchScreenshots(screenshots, dimensions, viewportHeight);\n            // 5. Extrair contexto da pgina\n            console.log('[FullPageCapture] Extraindo contexto...');\n            const context = yield extractFullPageContext(tabId);\n            const result = {\n                screenshot: fullScreenshot,\n                dimensions,\n                htmlContext: context.htmlContext,\n                textContext: context.textContext,\n                title: context.title,\n                url: (yield chrome.tabs.get(tabId)).url || '',\n                captureTime: Date.now() - startTime,\n                segments: segmentCount\n            };\n            console.log(`[FullPageCapture] Captura completa em ${result.captureTime}ms SEM afetar o usurio`);\n            return result;\n        }\n        catch (error) {\n            console.error('[FullPageCapture] Erro durante captura:', error);\n            throw new Error(`Falha na captura de pgina completa: ${error}`);\n        }\n    });\n}\n/**\n * Funo utilitria para comprimir screenshot se necessrio\n */\nexport function compressScreenshot(dataUrl, maxSizeKB = 1024) {\n    // Se a imagem for menor que o limite, retorna como est\n    const sizeKB = (dataUrl.length * 3 / 4) / 1024; // Aproximao do tamanho em KB\n    if (sizeKB <= maxSizeKB) {\n        return dataUrl;\n    }\n    // Criar canvas para recompresso\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n    return new Promise((resolve) => {\n        img.onload = () => {\n            // Reduzir qualidade progressivamente at atingir o tamanho desejado\n            let quality = 0.8;\n            let compressed = dataUrl;\n            while (quality > 0.1) {\n                canvas.width = img.width;\n                canvas.height = img.height;\n                ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, 0, 0);\n                compressed = canvas.toDataURL('image/jpeg', quality);\n                const newSizeKB = (compressed.length * 3 / 4) / 1024;\n                if (newSizeKB <= maxSizeKB) {\n                    break;\n                }\n                quality -= 0.1;\n            }\n            resolve(compressed);\n        };\n        img.src = dataUrl;\n    }); // Type assertion para compatibilidade\n}\n","// src/utils/performance.ts - Sistema de otimizaes de performance\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ErrorFactory, ErrorLogger } from './errors';\n/**\n * Debounce function para limitar chamadas frequentes\n */\nexport function debounce(func, delay) {\n    let timeoutId;\n    return (...args) => {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => func(...args), delay);\n    };\n}\n/**\n * Throttle function para limitar taxa de execuo\n */\nexport function throttle(func, limit) {\n    let inThrottle;\n    return (...args) => {\n        if (!inThrottle) {\n            func(...args);\n            inThrottle = true;\n            setTimeout(() => inThrottle = false, limit);\n        }\n    };\n}\n/**\n * Memoizao para funes puras\n */\nexport function memoize(func, getKey) {\n    const cache = new Map();\n    return ((...args) => {\n        const key = getKey ? getKey(...args) : JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = func(...args);\n        cache.set(key, result);\n        return result;\n    });\n}\n/**\n * Lazy loading para recursos pesados\n */\nexport class LazyLoader {\n    constructor(loader) {\n        this.promise = null;\n        this.result = null;\n        this.loader = loader;\n    }\n    load() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.result) {\n                return this.result;\n            }\n            if (!this.promise) {\n                this.promise = this.loader();\n            }\n            this.result = yield this.promise;\n            return this.result;\n        });\n    }\n    isLoaded() {\n        return this.result !== null;\n    }\n    reset() {\n        this.promise = null;\n        this.result = null;\n    }\n}\n/**\n * Pool de workers para processamento paralelo\n */\nexport class WorkerPool {\n    constructor(workerScript, poolSize = 4) {\n        this.workers = [];\n        this.availableWorkers = [];\n        this.taskQueue = [];\n        for (let i = 0; i < poolSize; i++) {\n            const worker = new Worker(workerScript);\n            this.workers.push(worker);\n            this.availableWorkers.push(worker);\n        }\n    }\n    execute(task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.taskQueue.push({ task, resolve, reject });\n                this.processQueue();\n            });\n        });\n    }\n    processQueue() {\n        if (this.taskQueue.length === 0 || this.availableWorkers.length === 0) {\n            return;\n        }\n        const worker = this.availableWorkers.pop();\n        const { task, resolve, reject } = this.taskQueue.shift();\n        const handleMessage = (event) => {\n            worker.removeEventListener('message', handleMessage);\n            worker.removeEventListener('error', handleError);\n            this.availableWorkers.push(worker);\n            resolve(event.data);\n            this.processQueue();\n        };\n        const handleError = (error) => {\n            worker.removeEventListener('message', handleMessage);\n            worker.removeEventListener('error', handleError);\n            this.availableWorkers.push(worker);\n            reject(error);\n            this.processQueue();\n        };\n        worker.addEventListener('message', handleMessage);\n        worker.addEventListener('error', handleError);\n        worker.postMessage(task);\n    }\n    destroy() {\n        this.workers.forEach(worker => worker.terminate());\n        this.workers = [];\n        this.availableWorkers = [];\n        this.taskQueue = [];\n    }\n}\n/**\n * Compresso de dados para reduzir uso de memria\n */\nexport class DataCompressor {\n    /**\n     * Comprime string usando algoritmo simples\n     */\n    static compress(data) {\n        try {\n            // Usa compresso simples baseada em repeties\n            return this.simpleCompress(data);\n        }\n        catch (error) {\n            ErrorLogger.log(ErrorFactory.validationFailure('compression', data, 'Failed to compress'));\n            return data; // Fallback para dados no comprimidos\n        }\n    }\n    /**\n     * Descomprime string\n     */\n    static decompress(compressedData) {\n        try {\n            return this.simpleDecompress(compressedData);\n        }\n        catch (error) {\n            ErrorLogger.log(ErrorFactory.validationFailure('decompression', compressedData, 'Failed to decompress'));\n            return compressedData; // Fallback\n        }\n    }\n    /**\n     * Compresso simples para fallback\n     */\n    static simpleCompress(data) {\n        const result = [];\n        let i = 0;\n        while (i < data.length) {\n            let count = 1;\n            const char = data[i];\n            while (i + count < data.length && data[i + count] === char && count < 255) {\n                count++;\n            }\n            if (count > 3) {\n                result.push(`${count}${char}`);\n            }\n            else {\n                result.push(char.repeat(count));\n            }\n            i += count;\n        }\n        return result.join('');\n    }\n    /**\n     * Descompresso simples\n     */\n    static simpleDecompress(data) {\n        return data.replace(/(\\d+)(.)/g, (match, count, char) => {\n            const num = parseInt(count, 10);\n            return num > 3 ? char.repeat(num) : match;\n        });\n    }\n}\n/**\n * Monitor de performance para mtricas\n */\nexport class PerformanceMonitor {\n    constructor() {\n        this.metrics = new Map();\n    }\n    /**\n     * Mede tempo de execuo de uma funo\n     */\n    measure(name, fn) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const startTime = performance.now();\n            try {\n                const result = yield fn();\n                this.recordMetric(name, performance.now() - startTime);\n                return result;\n            }\n            catch (error) {\n                this.recordMetric(name, performance.now() - startTime, true);\n                throw error;\n            }\n        });\n    }\n    /**\n     * Registra mtrica manualmente\n     */\n    recordMetric(name, time, isError = false) {\n        const existing = this.metrics.get(name) || {\n            count: 0,\n            totalTime: 0,\n            minTime: Infinity,\n            maxTime: 0,\n            lastTime: 0,\n        };\n        existing.count++;\n        existing.totalTime += time;\n        existing.minTime = Math.min(existing.minTime, time);\n        existing.maxTime = Math.max(existing.maxTime, time);\n        existing.lastTime = time;\n        this.metrics.set(name, existing);\n        // Log mtricas crticas\n        if (time > 5000) { // Mais de 5 segundos\n            ErrorLogger.log(ErrorFactory.timeoutFailure(name, time));\n        }\n    }\n    /**\n     * Obtm estatsticas de performance\n     */\n    getStats() {\n        const stats = {};\n        for (const [name, metric] of this.metrics.entries()) {\n            stats[name] = {\n                count: metric.count,\n                avgTime: metric.totalTime / metric.count,\n                minTime: metric.minTime === Infinity ? 0 : metric.minTime,\n                maxTime: metric.maxTime,\n                lastTime: metric.lastTime,\n            };\n        }\n        return stats;\n    }\n    /**\n     * Limpa mtricas antigas\n     */\n    clearStats() {\n        this.metrics.clear();\n    }\n}\n/**\n * Otimizador de imagens para reduzir tamanho\n */\nexport class ImageOptimizer {\n    /**\n     * Reduz qualidade de imagem base64\n     */\n    static optimizeBase64Image(base64Data, quality = 0.7, maxWidth = 1920, maxHeight = 1080) {\n        return new Promise((resolve) => {\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            const img = new Image();\n            img.onload = () => {\n                // Calcula dimenses otimizadas\n                let { width, height } = this.calculateOptimalDimensions(img.width, img.height, maxWidth, maxHeight);\n                canvas.width = width;\n                canvas.height = height;\n                // Desenha imagem redimensionada\n                ctx.drawImage(img, 0, 0, width, height);\n                // Converte para base64 com qualidade reduzida\n                const optimizedData = canvas.toDataURL('image/jpeg', quality);\n                resolve(optimizedData);\n            };\n            img.src = base64Data;\n        });\n    }\n    /**\n     * Calcula dimenses timas mantendo aspect ratio\n     */\n    static calculateOptimalDimensions(originalWidth, originalHeight, maxWidth, maxHeight) {\n        const aspectRatio = originalWidth / originalHeight;\n        let width = originalWidth;\n        let height = originalHeight;\n        if (width > maxWidth) {\n            width = maxWidth;\n            height = width / aspectRatio;\n        }\n        if (height > maxHeight) {\n            height = maxHeight;\n            width = height * aspectRatio;\n        }\n        return { width: Math.round(width), height: Math.round(height) };\n    }\n}\n/**\n * Batch processor para operaes em lote\n */\nexport class BatchProcessor {\n    constructor(processor, batchSize = 10, delay = 100) {\n        this.queue = [];\n        this.processing = false;\n        this.processor = processor;\n        this.batchSize = batchSize;\n        this.delay = delay;\n    }\n    add(item) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.queue.push(item);\n                // Adiciona resolver para este item especfico\n                const itemIndex = this.queue.length - 1;\n                setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.processing) {\n                        try {\n                            const results = yield this.processBatch();\n                            resolve(results[itemIndex]);\n                        }\n                        catch (error) {\n                            reject(error);\n                        }\n                    }\n                }), this.delay);\n            });\n        });\n    }\n    processBatch() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.processing || this.queue.length === 0) {\n                return [];\n            }\n            this.processing = true;\n            const batch = this.queue.splice(0, this.batchSize);\n            try {\n                const results = yield this.processor(batch);\n                return results;\n            }\n            finally {\n                this.processing = false;\n                // Processa prximo batch se houver itens na fila\n                if (this.queue.length > 0) {\n                    setTimeout(() => this.processBatch(), this.delay);\n                }\n            }\n        });\n    }\n}\n// Instncias globais\nexport const performanceMonitor = new PerformanceMonitor();\n","// src/utils/webSearch.ts - Sistema de Pesquisa Web Inteligente\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Detecta se uma resposta da IA indica necessidade de pesquisa web\n */\nexport function needsWebSearch(aiResponse, userQuestion) {\n    const needsSearchIndicators = [\n        'no est aqui nesta pgina',\n        'no consigo encontrar',\n        'no est visvel',\n        'preciso de mais informaes',\n        'no tenho informaes sobre',\n        'no est disponvel na pgina',\n        'precisa pesquisar',\n        'informao no est presente',\n        'no posso ver',\n        'no est mostrado'\n    ];\n    const responseText = aiResponse.toLowerCase();\n    const questionText = userQuestion.toLowerCase();\n    // Verifica se a resposta indica falta de informao\n    const hasNeedsIndicator = needsSearchIndicators.some(indicator => responseText.includes(indicator));\n    // Verifica se a pergunta  sobre algo especfico que pode precisar de busca\n    const isSpecificQuestion = [\n        'como', 'quando', 'onde', 'por que', 'quem', 'qual',\n        'preo', 'valor', 'custo', 'data', 'horrio',\n        'contato', 'telefone', 'endereo', 'email',\n        'novidades', 'notcias', 'atualizao'\n    ].some(keyword => questionText.includes(keyword));\n    return hasNeedsIndicator || (isSpecificQuestion && responseText.length < 200);\n}\n/**\n * Extrai termos de busca relevantes do contexto e pergunta do usurio\n */\nexport function extractSearchQuery(userQuestion, pageContext, pageUrl) {\n    // Limpar e normalizar a pergunta\n    let query = userQuestion.trim();\n    // Remover palavras de parada comuns\n    const stopWords = [\n        'o', 'a', 'os', 'as', 'um', 'uma', 'de', 'do', 'da', 'dos', 'das',\n        'em', 'no', 'na', 'nos', 'nas', 'para', 'por', 'com', 'sem',\n        'que', 'qual', 'quais', 'como', 'quando', 'onde', 'por que', 'porque',\n        'me', 'te', 'se', 'nos', 'vos', 'lhe', 'lhes',\n        'este', 'esta', 'estes', 'estas', 'esse', 'essa', 'esses', 'essas',\n        'aquele', 'aquela', 'aqueles', 'aquelas'\n    ];\n    // Extrair entidades importantes do contexto da pgina\n    const pageEntities = extractEntitiesFromContext(pageContext);\n    // Adicionar contexto relevante da pgina  busca\n    if (pageEntities.length > 0) {\n        const mainEntity = pageEntities[0];\n        if (!query.toLowerCase().includes(mainEntity.toLowerCase())) {\n            query = `${mainEntity} ${query}`;\n        }\n    }\n    // Adicionar domnio se relevante\n    if (pageUrl) {\n        const domain = new URL(pageUrl).hostname.replace('www.', '');\n        const siteName = domain.split('.')[0];\n        // Adicionar site se for relevante para a busca\n        if (['youtube', 'amazon', 'mercadolivre', 'olx', 'linkedin'].includes(siteName)) {\n            query = `site:${domain} ${query}`;\n        }\n    }\n    return query.trim();\n}\n/**\n * Extrai entidades importantes do contexto da pgina\n */\nfunction extractEntitiesFromContext(context) {\n    const entities = [];\n    // Extrair ttulos e cabealhos (geralmente so entidades importantes)\n    const titleMatches = context.match(/H[1-6]: ([^\\\\n]+)/g);\n    if (titleMatches) {\n        titleMatches.forEach(match => {\n            const title = match.replace(/H[1-6]: /, '').trim();\n            if (title.length > 3 && title.length < 100) {\n                entities.push(title);\n            }\n        });\n    }\n    // Extrair nomes prprios (palavras capitalizadas)\n    const properNouns = context.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b/g);\n    if (properNouns) {\n        properNouns.forEach(noun => {\n            if (noun.length > 3 && noun.length < 50 && !entities.includes(noun)) {\n                entities.push(noun);\n            }\n        });\n    }\n    return entities.slice(0, 3); // Retornar apenas as 3 mais relevantes\n}\n/**\n * Realiza pesquisa usando Google Custom Search API\n */\nfunction searchGoogle(query_1) {\n    return __awaiter(this, arguments, void 0, function* (query, options = {}) {\n        var _a;\n        const startTime = Date.now();\n        // Configuraes da API (voc precisar configurar essas chaves)\n        const API_KEY = yield getGoogleSearchApiKey();\n        const SEARCH_ENGINE_ID = yield getGoogleSearchEngineId();\n        if (!API_KEY || !SEARCH_ENGINE_ID) {\n            throw new Error('Google Search API no configurada');\n        }\n        const params = new URLSearchParams({\n            key: API_KEY,\n            cx: SEARCH_ENGINE_ID,\n            q: query,\n            num: Math.min(options.maxResults || 5, 10).toString(),\n            safe: options.safeSearch ? 'active' : 'off',\n            lr: options.language || 'lang_pt',\n            gl: options.region || 'br'\n        });\n        if (options.timeRange) {\n            const timeMap = {\n                'day': 'd1',\n                'week': 'w1',\n                'month': 'm1',\n                'year': 'y1'\n            };\n            params.append('dateRestrict', timeMap[options.timeRange]);\n        }\n        const response = yield fetch(`https://www.googleapis.com/customsearch/v1?${params}`);\n        if (!response.ok) {\n            throw new Error(`Google Search API error: ${response.status}`);\n        }\n        const data = yield response.json();\n        const results = (data.items || []).map((item, index) => ({\n            title: item.title,\n            url: item.link,\n            snippet: item.snippet,\n            displayUrl: item.displayLink,\n            position: index + 1\n        }));\n        return {\n            query,\n            results,\n            totalResults: parseInt(((_a = data.searchInformation) === null || _a === void 0 ? void 0 : _a.totalResults) || '0'),\n            searchTime: Date.now() - startTime,\n            source: 'google'\n        };\n    });\n}\n/**\n * Realiza pesquisa usando SerpAPI (alternativa mais simples)\n */\nfunction searchSerpAPI(query_1) {\n    return __awaiter(this, arguments, void 0, function* (query, options = {}) {\n        var _a;\n        const startTime = Date.now();\n        const API_KEY = yield getSerpApiKey();\n        if (!API_KEY) {\n            throw new Error('SerpAPI no configurada');\n        }\n        const params = new URLSearchParams({\n            api_key: API_KEY,\n            engine: 'google',\n            q: query,\n            num: Math.min(options.maxResults || 5, 10).toString(),\n            hl: options.language || 'pt',\n            gl: options.region || 'br',\n            safe: options.safeSearch ? 'active' : 'off'\n        });\n        const response = yield fetch(`https://serpapi.com/search?${params}`);\n        if (!response.ok) {\n            throw new Error(`SerpAPI error: ${response.status}`);\n        }\n        const data = yield response.json();\n        const results = (data.organic_results || []).map((item, index) => ({\n            title: item.title,\n            url: item.link,\n            snippet: item.snippet,\n            displayUrl: item.displayed_link,\n            position: index + 1\n        }));\n        return {\n            query,\n            results,\n            totalResults: ((_a = data.search_information) === null || _a === void 0 ? void 0 : _a.total_results) || 0,\n            searchTime: Date.now() - startTime,\n            source: 'serpapi'\n        };\n    });\n}\n/**\n * Funo principal de pesquisa web com fallback\n */\nexport function performWebSearch(query_1) {\n    return __awaiter(this, arguments, void 0, function* (query, options = {}) {\n        console.log(`[WebSearch] Pesquisando: \"${query}\"`);\n        try {\n            // Tentar SerpAPI primeiro (mais simples de configurar)\n            return yield searchSerpAPI(query, options);\n        }\n        catch (serpError) {\n            console.warn('[WebSearch] SerpAPI falhou, tentando Google:', serpError);\n            try {\n                // Fallback para Google Custom Search\n                return yield searchGoogle(query, options);\n            }\n            catch (googleError) {\n                console.error('[WebSearch] Todas as APIs falharam:', { serpError, googleError });\n                throw new Error('Pesquisa web indisponvel no momento');\n            }\n        }\n    });\n}\n/**\n * Combina resultados de pesquisa com contexto da pgina\n */\nexport function combineSearchWithPageContext(pageContext, searchResults, userQuestion) {\n    const searchSummary = searchResults.results\n        .slice(0, 3) // Usar apenas os 3 primeiros resultados\n        .map(result => `**${result.title}**\\n${result.snippet}\\nFonte: ${result.displayUrl}`)\n        .join('\\n\\n');\n    return `CONTEXTO DA PGINA ATUAL:\n${pageContext}\n\nINFORMAES ADICIONAIS DA WEB (pesquisa: \"${searchResults.query}\"):\n${searchSummary}\n\nPERGUNTA DO USURIO: ${userQuestion}\n\nUse tanto o contexto da pgina quanto as informaes da web para fornecer uma resposta completa e til.`;\n}\n// Funes para obter chaves de API (implementar conforme necessrio)\nfunction getGoogleSearchApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get('googleSearchApiKey');\n        return result.googleSearchApiKey || null;\n    });\n}\nfunction getGoogleSearchEngineId() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get('googleSearchEngineId');\n        return result.googleSearchEngineId || null;\n    });\n}\nfunction getSerpApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get('serpApiKey');\n        return result.serpApiKey || null;\n    });\n}\n/**\n * Funo utilitria para testar se as APIs esto configuradas\n */\nexport function checkWebSearchAvailability() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const serpApiKey = yield getSerpApiKey();\n        const googleApiKey = yield getGoogleSearchApiKey();\n        const googleEngineId = yield getGoogleSearchEngineId();\n        const serpapi = !!serpApiKey;\n        const google = !!(googleApiKey && googleEngineId);\n        return {\n            serpapi,\n            google,\n            available: serpapi || google\n        };\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// src/background/main.ts - VERSO COM CACHE, PERFORMANCE E TRATAMENTO DE ERROS ROBUSTO\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport { getGeminiApiKey } from \"./config\";\nimport { ErrorFactory, ErrorLogger, withErrorHandling, withTimeout } from \"../utils/errors\";\nimport { aiResponseCache, pageContextCache } from \"../utils/cache\";\nimport { throttle, performanceMonitor } from \"../utils/performance\";\nimport { captureFullPage } from \"../utils/fullPageCapture\";\nimport { performWebSearch, needsWebSearch, extractSearchQuery, combineSearchWithPageContext, checkWebSearchAvailability } from \"../utils/webSearch\";\n// Instncia global que ser inicializada quando necessrio\nlet genAI = null;\nlet model = null;\n// Funes auxiliares para cache e performance\nconst throttledAIRequest = throttle(makeAIRequest, 1000);\n/**\n * Gera chave de cache baseada no contedo da pgina\n */\nfunction generateCacheKey(url, content) {\n    const contentHash = btoa(content.substring(0, 1000)).substring(0, 32);\n    return `${url}_${contentHash}`;\n}\n/**\n * Funo genrica para fazer requisies  IA com cache e retry\n */\nfunction makeAIRequest(prompt, parts, cacheKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return performanceMonitor.measure('ai_request', () => __awaiter(this, void 0, void 0, function* () {\n            // Verifica cache se a chave foi fornecida\n            if (cacheKey) {\n                const cached = yield aiResponseCache.get(cacheKey);\n                if (cached) {\n                    console.log(`[CACHE] Cache hit for key: ${cacheKey}`);\n                    return { response: { text: () => cached } };\n                }\n            }\n            // Implementa retry com timeouts progressivos\n            const maxRetries = 2;\n            const timeouts = [10000, 20000]; // 10s, 20s\n            for (let attempt = 0; attempt <= maxRetries; attempt++) {\n                try {\n                    console.log(`[AI] Tentativa ${attempt + 1}/${maxRetries + 1} - Timeout: ${timeouts[attempt] || 20000}ms`);\n                    const result = yield withTimeout(() => model.generateContent([prompt, ...parts]), timeouts[attempt] || 20000, `ai_request_attempt_${attempt + 1}`);\n                    const responseText = result.response.text();\n                    // Armazena no cache se a chave foi fornecida\n                    if (cacheKey && responseText) {\n                        yield aiResponseCache.set(cacheKey, responseText);\n                        console.log(`[CACHE] Cache stored for key: ${cacheKey}`);\n                    }\n                    return result;\n                }\n                catch (error) {\n                    console.log(`[AI] Tentativa ${attempt + 1} falhou:`, error.message);\n                    // Se  a ltima tentativa, lana o erro\n                    if (attempt === maxRetries) {\n                        throw error;\n                    }\n                    // Aguarda antes da prxima tentativa\n                    yield new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n                }\n            }\n        }));\n    });\n}\n/**\n * Inicializa o cliente Gemini AI com a API key do storage\n * @throws {ApiKeyError} Se a API key no estiver configurada\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nfunction initializeGeminiAI() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            const apiKey = yield getGeminiApiKey();\n            if (!apiKey) {\n                throw ErrorFactory.apiKeyNotConfigured();\n            }\n            genAI = new GoogleGenerativeAI(apiKey);\n            model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\n        }), (error) => {\n            if (error.code === 'API_KEY_ERROR' || error.code === 'STORAGE_ERROR') {\n                return error;\n            }\n            return ErrorFactory.geminiApiFailure(error);\n        });\n    });\n}\nchrome.commands.onCommand.addListener((command) => __awaiter(void 0, void 0, void 0, function* () {\n    if (command === \"open_chat\") {\n        yield chrome.storage.local.clear();\n        yield chrome.action.openPopup();\n    }\n}));\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.type === \"CAPTURE_FULL_PAGE\") {\n        // Usar funo assncrona separada para evitar problemas de message port\n        (() => __awaiter(void 0, void 0, void 0, function* () {\n            try {\n                console.log('[Background] Iniciando captura de pgina completa...');\n                const fullPageResult = yield captureFullPage(request.tabId, request.windowId, {\n                    maxHeight: 8000,\n                    quality: 70,\n                    format: 'jpeg',\n                    waitTime: 200 // Reduzido para evitar rate limit\n                });\n                console.log(`[Background] Captura completa: ${fullPageResult.segments} segmentos, ${fullPageResult.captureTime}ms`);\n                sendResponse(fullPageResult);\n            }\n            catch (error) {\n                console.error('[Background] Erro na captura de pgina completa:', error);\n                sendResponse({ error: `Erro na captura: ${error}` });\n            }\n        }))();\n        return true; // Manter porta aberta para resposta assncrona\n    }\n    else if (request.type === \"START_MULTIMODAL_CHAT\") {\n        const runChatInitialization = () => __awaiter(void 0, void 0, void 0, function* () {\n            var _a, _b;\n            try {\n                // Verifica se a API key est configurada e inicializa o modelo\n                if (!model) {\n                    try {\n                        yield initializeGeminiAI();\n                    }\n                    catch (error) {\n                        const errorMessage = error.userMessage || 'API key do Gemini no configurada. Por favor, configure nas opes da extenso.';\n                        sendResponse({ error: errorMessage });\n                        return;\n                    }\n                }\n                const { fullPageResult, pageContext } = request;\n                // Validar se a captura completa foi bem-sucedida\n                if (!fullPageResult || fullPageResult.error) {\n                    throw new Error(`Captura de pgina falhou: ${(fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.error) || 'Resultado vazio'}`);\n                }\n                // Usar screenshot da captura completa\n                const screenshotDataUrl = fullPageResult.screenshot;\n                // Validao adicional do screenshot\n                if (!screenshotDataUrl || screenshotDataUrl.length < 100) {\n                    throw new Error('Screenshot da pgina completa est vazio ou invlido');\n                }\n                console.log(`[Background] Screenshot vlido recebido: ${screenshotDataUrl.length} caracteres`);\n                // Destilao de contexto com cache inteligente\n                const url = ((_a = sender.tab) === null || _a === void 0 ? void 0 : _a.url) || 'unknown';\n                const contextCacheKey = generateCacheKey(url, pageContext.htmlContent || '');\n                // Verifica cache de contexto da pgina primeiro\n                let distilledContext = yield pageContextCache.get(contextCacheKey);\n                if (!distilledContext) {\n                    const distillationResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                        // Usa o screenshot j capturado pelo popup\n                        // Validao final antes de usar com a IA\n                        if (!screenshotDataUrl || screenshotDataUrl.length < 100) {\n                            throw new Error(\"Screenshot da pgina completa no disponvel ou invlido\");\n                        }\n                        console.log(`[Background] Usando captura completa: ${fullPageResult.segments} segmentos, ${fullPageResult.captureTime}ms, ${screenshotDataUrl.length} chars`);\n                        // Prompt otimizado e mais direto\n                        const prompt = `Analise esta pgina web brevemente. Liste apenas os pontos principais: contedo, funcionalidades e elementos importantes. Seja conciso.`;\n                        const imagePart = {\n                            inlineData: {\n                                data: screenshotDataUrl.split(',')[1],\n                                mimeType: 'image/jpeg'\n                            }\n                        };\n                        // Limita o contedo HTML para evitar requisies muito grandes\n                        const limitedHtmlContent = (pageContext.htmlContent || '').substring(0, 2000);\n                        return yield makeAIRequest(prompt, [imagePart, limitedHtmlContent], `distill_${contextCacheKey}`);\n                    }), (error) => ErrorFactory.geminiApiFailure(error));\n                    distilledContext = yield distillationResult.response.text();\n                    // Armazena contexto no cache de pgina\n                    if (distilledContext) {\n                        yield pageContextCache.set(contextCacheKey, distilledContext);\n                    }\n                }\n                // Garante que distilledContext no seja null\n                const finalContext = distilledContext || 'Contexto no disponvel';\n                yield chrome.storage.local.set({ distilledContext: finalContext });\n                // Gerao da saudao com tratamento de erro\n                const openingResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                    var _a, _b;\n                    const friendlyPrompt = `Voc  um colega de trabalho experiente e amigvel que acabou de passar pela mesa do usurio e viu o que ele est fazendo no navegador.\n\nCONTEXTO COMPLETO DA PGINA:\nTtulo: ${pageContext.title}\nURL: ${(fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.url) || 'N/A'}\nDimenses capturadas: ${(_a = fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.dimensions) === null || _a === void 0 ? void 0 : _a.width}x${(_b = fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.dimensions) === null || _b === void 0 ? void 0 : _b.height}px\nSegmentos de tela: ${(fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.segments) || 1}\nContedo: ${pageContext.textContent}\n\nVoc pode ver a pgina COMPLETA (no apenas o que est visvel), incluindo todo o contedo que pode estar fora da tela. Use essa viso completa para oferecer ajuda mais precisa.\n\nAborde o usurio de forma natural e amigvel, como se voc tivesse visto o que ele est fazendo e quer ajudar. Seja proativo e til!\n\nExemplos de abordagem:\n- \"Opa! Vi que voc est no [site/contedo]. Posso te ajudar com alguma coisa?\"\n- \"Interessante esse [tpico]! Tem alguma dvida especfica que eu posso esclarecer?\"\n- \"Notei que voc est pesquisando sobre [assunto]. Quer que eu complemente com algumas informaes?\"\n\nSeja sempre til e tente fornecer informaes valiosas baseadas no que voc v na tela COMPLETA.`;\n                    return yield withTimeout(() => model.generateContent(friendlyPrompt), 15000, 'greetingGeneration');\n                }), (error) => ErrorFactory.geminiApiFailure(error));\n                const initialMessage = { role: 'model', text: openingResult.response.text() };\n                sendResponse(initialMessage);\n                // Salvar TANTO a conversa QUANTO o contexto completo para continuidade\n                yield chrome.storage.local.set({\n                    activeConversation: { url: (_b = sender.tab) === null || _b === void 0 ? void 0 : _b.url, history: [initialMessage] },\n                    fullPageContext: fullPageResult // Salvar screenshot e metadados completos\n                });\n                console.log('[Background] Contexto completo salvo para continuidade do chat');\n            }\n            catch (error) {\n                ErrorLogger.log(error);\n                const errorMessage = error.userMessage || `Erro ao analisar a pgina: ${error.message}`;\n                sendResponse({ error: errorMessage });\n            }\n        });\n        runChatInitialization();\n        return true;\n    }\n    else if (request.type === \"SEND_CHAT_MESSAGE\") {\n        const runContinueChat = () => __awaiter(void 0, void 0, void 0, function* () {\n            var _a;\n            try {\n                // Verifica se a API key est configurada e inicializa o modelo\n                if (!model) {\n                    try {\n                        yield initializeGeminiAI();\n                    }\n                    catch (error) {\n                        const errorMessage = error.userMessage || 'API key do Gemini no configurada. Por favor, configure nas opes da extenso.';\n                        sendResponse({ error: errorMessage });\n                        return;\n                    }\n                }\n                const currentHistory = request.history;\n                // Recuperar TANTO o contexto destilado QUANTO o screenshot original\n                const data = yield chrome.storage.local.get(['distilledContext', 'fullPageContext']);\n                if (!data.distilledContext)\n                    throw new Error(\"Contexto destilado no encontrado.\");\n                // Obter a ltima pergunta do usurio\n                const lastUserMessage = currentHistory[currentHistory.length - 1];\n                const userQuestion = (lastUserMessage === null || lastUserMessage === void 0 ? void 0 : lastUserMessage.text) || '';\n                // Primeira tentativa: resposta com contexto da pgina\n                const initialResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                    var _a, _b, _c;\n                    // Preparar contedo multimodal se screenshot estiver disponvel\n                    const parts = [];\n                    // Adicionar screenshot se disponvel (mantm contexto visual)\n                    if ((_a = data.fullPageContext) === null || _a === void 0 ? void 0 : _a.screenshot) {\n                        parts.push({\n                            inlineData: {\n                                mimeType: \"image/jpeg\",\n                                data: data.fullPageContext.screenshot.split(',')[1]\n                            }\n                        });\n                        console.log('[Background] Usando screenshot completo na continuao do chat');\n                    }\n                    // Prompt melhorado que mantm contexto visual + textual\n                    const contextPrompt = `Voc  um colega de trabalho amigvel que pode ver esta pgina completa.\n\nCONTEXTO DA PGINA:\n${data.distilledContext}\n\n${data.fullPageContext ? `INFORMAES ADICIONAIS:\n- Dimenses: ${(_b = data.fullPageContext.dimensions) === null || _b === void 0 ? void 0 : _b.width}x${(_c = data.fullPageContext.dimensions) === null || _c === void 0 ? void 0 : _c.height}px\n- Segmentos capturados: ${data.fullPageContext.segments}\n- URL: ${data.fullPageContext.url}\n` : ''}\nVoc pode ver a pgina COMPLETA (incluindo partes fora da tela) e deve usar tanto a viso visual quanto o contexto textual para responder.\n\nSe a informao no estiver visvel na pgina, responda \"PRECISO_PESQUISAR\" seguido de uma explicao breve do que precisa buscar. Use formatao Markdown.\n\nHISTRICO DA CONVERSA:`;\n                    parts.push({ text: contextPrompt });\n                    const promptForGenerativeModel = [\n                        { role: \"user\", parts },\n                        ...currentHistory.map(msg => ({ role: msg.role, parts: [{ text: msg.text }] }))\n                    ];\n                    return yield withTimeout(() => model.generateContent({ contents: promptForGenerativeModel }), 20000, 'chatContinuation');\n                }), (error) => ErrorFactory.geminiApiFailure(error));\n                const initialResponse = initialResult.response.text();\n                // Verificar se precisa de pesquisa web\n                const needsSearch = needsWebSearch(initialResponse, userQuestion) || initialResponse.includes('PRECISO_PESQUISAR');\n                let finalResult = initialResult;\n                if (needsSearch) {\n                    console.log('[Background] IA indicou necessidade de pesquisa web');\n                    // Verificar se pesquisa web est disponvel\n                    const searchAvailability = yield checkWebSearchAvailability();\n                    if (searchAvailability.available) {\n                        try {\n                            // Extrair query de pesquisa\n                            const searchQuery = extractSearchQuery(userQuestion, data.distilledContext, (_a = data.fullPageContext) === null || _a === void 0 ? void 0 : _a.url);\n                            console.log(`[Background] Pesquisando na web: \"${searchQuery}\"`);\n                            // Realizar pesquisa\n                            const searchResults = yield performWebSearch(searchQuery, {\n                                maxResults: 3,\n                                language: 'pt',\n                                region: 'br'\n                            });\n                            // Combinar contexto da pgina com resultados da pesquisa\n                            const enhancedContext = combineSearchWithPageContext(data.distilledContext, searchResults, userQuestion);\n                            // Gerar resposta final com contexto expandido\n                            const enhancedResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                                var _a;\n                                const parts = [];\n                                // Adicionar screenshot se disponvel\n                                if ((_a = data.fullPageContext) === null || _a === void 0 ? void 0 : _a.screenshot) {\n                                    parts.push({\n                                        inlineData: {\n                                            mimeType: \"image/jpeg\",\n                                            data: data.fullPageContext.screenshot.split(',')[1]\n                                        }\n                                    });\n                                }\n                                const enhancedPrompt = `Voc  um colega de trabalho expert que tem acesso tanto  pgina atual quanto a informaes da web.\n\n${enhancedContext}\n\nAgora responda de forma completa e til, combinando as informaes da pgina com os dados da web. Seja natural e amigvel, como um colega que realmente quer ajudar.\n\nHISTRICO DA CONVERSA:`;\n                                parts.push({ text: enhancedPrompt });\n                                const promptForGenerativeModel = [\n                                    { role: \"user\", parts },\n                                    ...currentHistory.map(msg => ({ role: msg.role, parts: [{ text: msg.text }] }))\n                                ];\n                                return yield withTimeout(() => model.generateContent({ contents: promptForGenerativeModel }), 25000, 'enhancedChatContinuation');\n                            }), (error) => ErrorFactory.geminiApiFailure(error));\n                            finalResult = enhancedResult;\n                            console.log(`[Background] Resposta gerada com pesquisa web (${searchResults.results.length} resultados)`);\n                        }\n                        catch (searchError) {\n                            console.error('[Background] Erro na pesquisa web:', searchError);\n                            // Usar resposta inicial se pesquisa falhar\n                            console.log('[Background] Usando resposta inicial devido a erro na pesquisa');\n                        }\n                    }\n                    else {\n                        console.log('[Background] Pesquisa web no disponvel (APIs no configuradas)');\n                        // Modificar resposta inicial para informar sobre limitao\n                        const limitedResponse = initialResponse.replace('PRECISO_PESQUISAR', 'Hmm, essa informao no est visvel nesta pgina. Para ter acesso a pesquisas na web,  necessrio configurar uma API de busca nas configuraes da extenso.');\n                        finalResult = {\n                            response: {\n                                text: () => limitedResponse\n                            }\n                        };\n                    }\n                }\n                const result = finalResult;\n                const newAIMessage = { role: 'model', text: result.response.text() };\n                sendResponse({ text: newAIMessage.text });\n                const updatedHistory = [...currentHistory, newAIMessage];\n                const currentConversation = yield chrome.storage.local.get(\"activeConversation\");\n                yield chrome.storage.local.set({\n                    activeConversation: Object.assign(Object.assign({}, currentConversation.activeConversation), { history: updatedHistory })\n                });\n            }\n            catch (error) {\n                ErrorLogger.log(error);\n                const errorMessage = error.userMessage || error.message;\n                sendResponse({ error: errorMessage });\n            }\n        });\n        runContinueChat();\n        return true;\n    }\n});\n"],"names":[],"sourceRoot":""}