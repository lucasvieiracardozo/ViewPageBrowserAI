{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://viewpagebrowserai/./node_modules/@google/generative-ai/dist/index.mjs","webpack://viewpagebrowserai/./src/background/config.ts","webpack://viewpagebrowserai/./src/utils/cache.ts","webpack://viewpagebrowserai/./src/utils/errors.ts","webpack://viewpagebrowserai/./src/utils/fullPageCapture.ts","webpack://viewpagebrowserai/./src/utils/performance.ts","webpack://viewpagebrowserai/./src/utils/webSearch.ts","webpack://viewpagebrowserai/webpack/bootstrap","webpack://viewpagebrowserai/webpack/runtime/define property getters","webpack://viewpagebrowserai/webpack/runtime/hasOwnProperty shorthand","webpack://viewpagebrowserai/webpack/runtime/make namespace object","webpack://viewpagebrowserai/./src/background/main.ts"],"sourcesContent":["/**\n * Contains the list of OpenAPI data types\n * as defined by https://swagger.io/docs/specification/data-models/data-types/\n * @public\n */\nvar SchemaType;\n(function (SchemaType) {\n    /** String type. */\n    SchemaType[\"STRING\"] = \"string\";\n    /** Number type. */\n    SchemaType[\"NUMBER\"] = \"number\";\n    /** Integer type. */\n    SchemaType[\"INTEGER\"] = \"integer\";\n    /** Boolean type. */\n    SchemaType[\"BOOLEAN\"] = \"boolean\";\n    /** Array type. */\n    SchemaType[\"ARRAY\"] = \"array\";\n    /** Object type. */\n    SchemaType[\"OBJECT\"] = \"object\";\n})(SchemaType || (SchemaType = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @public\n */\nvar ExecutableCodeLanguage;\n(function (ExecutableCodeLanguage) {\n    ExecutableCodeLanguage[\"LANGUAGE_UNSPECIFIED\"] = \"language_unspecified\";\n    ExecutableCodeLanguage[\"PYTHON\"] = \"python\";\n})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));\n/**\n * Possible outcomes of code execution.\n * @public\n */\nvar Outcome;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"outcome_unspecified\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"outcome_ok\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the\n     * reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"outcome_failed\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not\n     * be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"outcome_deadline_exceeded\";\n})(Outcome || (Outcome = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Possible roles.\n * @public\n */\nconst POSSIBLE_ROLES = [\"user\", \"model\", \"function\", \"system\"];\n/**\n * Harm categories that would cause prompts or candidates to be blocked.\n * @public\n */\nvar HarmCategory;\n(function (HarmCategory) {\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n})(HarmCategory || (HarmCategory = {}));\n/**\n * Threshold above which a prompt or candidate will be blocked.\n * @public\n */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n    /** Threshold is unspecified. */\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /** Content with NEGLIGIBLE will be allowed. */\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /** Content with NEGLIGIBLE and LOW will be allowed. */\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /** Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed. */\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /** All content will be allowed. */\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/**\n * Probability that a prompt or candidate matches a harm category.\n * @public\n */\nvar HarmProbability;\n(function (HarmProbability) {\n    /** Probability is unspecified. */\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /** Content has a negligible chance of being unsafe. */\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /** Content has a low chance of being unsafe. */\n    HarmProbability[\"LOW\"] = \"LOW\";\n    /** Content has a medium chance of being unsafe. */\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /** Content has a high chance of being unsafe. */\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/**\n * Reason that a prompt was blocked.\n * @public\n */\nvar BlockReason;\n(function (BlockReason) {\n    // A blocked reason was not specified.\n    BlockReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    // Content was blocked by safety settings.\n    BlockReason[\"SAFETY\"] = \"SAFETY\";\n    // Content was blocked, but the reason is uncategorized.\n    BlockReason[\"OTHER\"] = \"OTHER\";\n})(BlockReason || (BlockReason = {}));\n/**\n * Reason that a candidate finished.\n * @public\n */\nvar FinishReason;\n(function (FinishReason) {\n    // Default value. This value is unused.\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    // Natural stop point of the model or provided stop sequence.\n    FinishReason[\"STOP\"] = \"STOP\";\n    // The maximum number of tokens as specified in the request was reached.\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    // The candidate content was flagged for safety reasons.\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    // The candidate content was flagged for recitation reasons.\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    // The candidate content was flagged for using an unsupported language.\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    // Token generation stopped because the content contains forbidden terms.\n    FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    // Token generation stopped for potentially containing prohibited content.\n    FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    // Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n    FinishReason[\"SPII\"] = \"SPII\";\n    // The function call generated by the model is invalid.\n    FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    // Unknown reason.\n    FinishReason[\"OTHER\"] = \"OTHER\";\n})(FinishReason || (FinishReason = {}));\n/**\n * Task type for embedding content.\n * @public\n */\nvar TaskType;\n(function (TaskType) {\n    TaskType[\"TASK_TYPE_UNSPECIFIED\"] = \"TASK_TYPE_UNSPECIFIED\";\n    TaskType[\"RETRIEVAL_QUERY\"] = \"RETRIEVAL_QUERY\";\n    TaskType[\"RETRIEVAL_DOCUMENT\"] = \"RETRIEVAL_DOCUMENT\";\n    TaskType[\"SEMANTIC_SIMILARITY\"] = \"SEMANTIC_SIMILARITY\";\n    TaskType[\"CLASSIFICATION\"] = \"CLASSIFICATION\";\n    TaskType[\"CLUSTERING\"] = \"CLUSTERING\";\n})(TaskType || (TaskType = {}));\n/**\n * @public\n */\nvar FunctionCallingMode;\n(function (FunctionCallingMode) {\n    // Unspecified function calling mode. This value should not be used.\n    FunctionCallingMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    // Default model behavior, model decides to predict either a function call\n    // or a natural language repspose.\n    FunctionCallingMode[\"AUTO\"] = \"AUTO\";\n    // Model is constrained to always predicting a function call only.\n    // If \"allowed_function_names\" are set, the predicted function call will be\n    // limited to any one of \"allowed_function_names\", else the predicted\n    // function call will be any one of the provided \"function_declarations\".\n    FunctionCallingMode[\"ANY\"] = \"ANY\";\n    // Model will not predict any function call. Model behavior is same as when\n    // not passing any function declarations.\n    FunctionCallingMode[\"NONE\"] = \"NONE\";\n})(FunctionCallingMode || (FunctionCallingMode = {}));\n/**\n * The mode of the predictor to be used in dynamic retrieval.\n * @public\n */\nvar DynamicRetrievalMode;\n(function (DynamicRetrievalMode) {\n    // Unspecified function calling mode. This value should not be used.\n    DynamicRetrievalMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    // Run retrieval only when system decides it is necessary.\n    DynamicRetrievalMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Basic error type for this SDK.\n * @public\n */\nclass GoogleGenerativeAIError extends Error {\n    constructor(message) {\n        super(`[GoogleGenerativeAI Error]: ${message}`);\n    }\n}\n/**\n * Errors in the contents of a response from the model. This includes parsing\n * errors, or responses including a safety block reason.\n * @public\n */\nclass GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n    }\n}\n/**\n * Error class covering HTTP errors when calling the server. Includes HTTP\n * status, statusText, and optional details, if provided in the server response.\n * @public\n */\nclass GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {\n    constructor(message, status, statusText, errorDetails) {\n        super(message);\n        this.status = status;\n        this.statusText = statusText;\n        this.errorDetails = errorDetails;\n    }\n}\n/**\n * Errors in the contents of a request originating from user input.\n * @public\n */\nclass GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {\n}\n/**\n * Error thrown when a request is aborted, either due to a timeout or\n * intentional cancellation by the user.\n * @public\n */\nclass GoogleGenerativeAIAbortError extends GoogleGenerativeAIError {\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_BASE_URL = \"https://generativelanguage.googleapis.com\";\nconst DEFAULT_API_VERSION = \"v1beta\";\n/**\n * We can't `require` package.json if this runs on web. We will use rollup to\n * swap in the version number here at build time.\n */\nconst PACKAGE_VERSION = \"0.24.1\";\nconst PACKAGE_LOG_HEADER = \"genai-js\";\nvar Task;\n(function (Task) {\n    Task[\"GENERATE_CONTENT\"] = \"generateContent\";\n    Task[\"STREAM_GENERATE_CONTENT\"] = \"streamGenerateContent\";\n    Task[\"COUNT_TOKENS\"] = \"countTokens\";\n    Task[\"EMBED_CONTENT\"] = \"embedContent\";\n    Task[\"BATCH_EMBED_CONTENTS\"] = \"batchEmbedContents\";\n})(Task || (Task = {}));\nclass RequestUrl {\n    constructor(model, task, apiKey, stream, requestOptions) {\n        this.model = model;\n        this.task = task;\n        this.apiKey = apiKey;\n        this.stream = stream;\n        this.requestOptions = requestOptions;\n    }\n    toString() {\n        var _a, _b;\n        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;\n        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;\n        let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;\n        if (this.stream) {\n            url += \"?alt=sse\";\n        }\n        return url;\n    }\n}\n/**\n * Simple, but may become more complex if we add more versions to log.\n */\nfunction getClientHeaders(requestOptions) {\n    const clientHeaders = [];\n    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {\n        clientHeaders.push(requestOptions.apiClient);\n    }\n    clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);\n    return clientHeaders.join(\" \");\n}\nasync function getHeaders(url) {\n    var _a;\n    const headers = new Headers();\n    headers.append(\"Content-Type\", \"application/json\");\n    headers.append(\"x-goog-api-client\", getClientHeaders(url.requestOptions));\n    headers.append(\"x-goog-api-key\", url.apiKey);\n    let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;\n    if (customHeaders) {\n        if (!(customHeaders instanceof Headers)) {\n            try {\n                customHeaders = new Headers(customHeaders);\n            }\n            catch (e) {\n                throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);\n            }\n        }\n        for (const [headerName, headerValue] of customHeaders.entries()) {\n            if (headerName === \"x-goog-api-key\") {\n                throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);\n            }\n            else if (headerName === \"x-goog-api-client\") {\n                throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);\n            }\n            headers.append(headerName, headerValue);\n        }\n    }\n    return headers;\n}\nasync function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {\n    const url = new RequestUrl(model, task, apiKey, stream, requestOptions);\n    return {\n        url: url.toString(),\n        fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: \"POST\", headers: await getHeaders(url), body }),\n    };\n}\nasync function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, \n// Allows this to be stubbed for tests\nfetchFn = fetch) {\n    const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);\n    return makeRequest(url, fetchOptions, fetchFn);\n}\nasync function makeRequest(url, fetchOptions, fetchFn = fetch) {\n    let response;\n    try {\n        response = await fetchFn(url, fetchOptions);\n    }\n    catch (e) {\n        handleResponseError(e, url);\n    }\n    if (!response.ok) {\n        await handleResponseNotOk(response, url);\n    }\n    return response;\n}\nfunction handleResponseError(e, url) {\n    let err = e;\n    if (err.name === \"AbortError\") {\n        err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);\n        err.stack = e.stack;\n    }\n    else if (!(e instanceof GoogleGenerativeAIFetchError ||\n        e instanceof GoogleGenerativeAIRequestInputError)) {\n        err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);\n        err.stack = e.stack;\n    }\n    throw err;\n}\nasync function handleResponseNotOk(response, url) {\n    let message = \"\";\n    let errorDetails;\n    try {\n        const json = await response.json();\n        message = json.error.message;\n        if (json.error.details) {\n            message += ` ${JSON.stringify(json.error.details)}`;\n            errorDetails = json.error.details;\n        }\n    }\n    catch (e) {\n        // ignored\n    }\n    throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);\n}\n/**\n * Generates the request options to be passed to the fetch API.\n * @param requestOptions - The user-defined request options.\n * @returns The generated request options.\n */\nfunction buildFetchOptions(requestOptions) {\n    const fetchOptions = {};\n    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n        const controller = new AbortController();\n        if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n            setTimeout(() => controller.abort(), requestOptions.timeout);\n        }\n        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {\n            requestOptions.signal.addEventListener(\"abort\", () => {\n                controller.abort();\n            });\n        }\n        fetchOptions.signal = controller.signal;\n    }\n    return fetchOptions;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Adds convenience helper methods to a response object, including stream\n * chunks (as long as each chunk is a complete GenerateContentResponse JSON).\n */\nfunction addHelpers(response) {\n    response.text = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning text from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            return getText(response);\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return \"\";\n    };\n    /**\n     * TODO: remove at next major version\n     */\n    response.functionCall = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning function calls from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            console.warn(`response.functionCall() is deprecated. ` +\n                `Use response.functionCalls() instead.`);\n            return getFunctionCalls(response)[0];\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return undefined;\n    };\n    response.functionCalls = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning function calls from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            return getFunctionCalls(response);\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return undefined;\n    };\n    return response;\n}\n/**\n * Returns all text found in all parts of first candidate.\n */\nfunction getText(response) {\n    var _a, _b, _c, _d;\n    const textStrings = [];\n    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {\n        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {\n            if (part.text) {\n                textStrings.push(part.text);\n            }\n            if (part.executableCode) {\n                textStrings.push(\"\\n```\" +\n                    part.executableCode.language +\n                    \"\\n\" +\n                    part.executableCode.code +\n                    \"\\n```\\n\");\n            }\n            if (part.codeExecutionResult) {\n                textStrings.push(\"\\n```\\n\" + part.codeExecutionResult.output + \"\\n```\\n\");\n            }\n        }\n    }\n    if (textStrings.length > 0) {\n        return textStrings.join(\"\");\n    }\n    else {\n        return \"\";\n    }\n}\n/**\n * Returns functionCall of first candidate.\n */\nfunction getFunctionCalls(response) {\n    var _a, _b, _c, _d;\n    const functionCalls = [];\n    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {\n        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {\n            if (part.functionCall) {\n                functionCalls.push(part.functionCall);\n            }\n        }\n    }\n    if (functionCalls.length > 0) {\n        return functionCalls;\n    }\n    else {\n        return undefined;\n    }\n}\nconst badFinishReasons = [\n    FinishReason.RECITATION,\n    FinishReason.SAFETY,\n    FinishReason.LANGUAGE,\n];\nfunction hadBadFinishReason(candidate) {\n    return (!!candidate.finishReason &&\n        badFinishReasons.includes(candidate.finishReason));\n}\nfunction formatBlockErrorMessage(response) {\n    var _a, _b, _c;\n    let message = \"\";\n    if ((!response.candidates || response.candidates.length === 0) &&\n        response.promptFeedback) {\n        message += \"Response was blocked\";\n        if ((_a = response.promptFeedback) === null || _a === void 0 ? void 0 : _a.blockReason) {\n            message += ` due to ${response.promptFeedback.blockReason}`;\n        }\n        if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {\n            message += `: ${response.promptFeedback.blockReasonMessage}`;\n        }\n    }\n    else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {\n        const firstCandidate = response.candidates[0];\n        if (hadBadFinishReason(firstCandidate)) {\n            message += `Candidate was blocked due to ${firstCandidate.finishReason}`;\n            if (firstCandidate.finishMessage) {\n                message += `: ${firstCandidate.finishMessage}`;\n            }\n        }\n    }\n    return message;\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst responseLineRE = /^data\\: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * Process a response.body stream from the backend and return an\n * iterator that provides one complete GenerateContentResponse at a time\n * and a promise that resolves with a single aggregated\n * GenerateContentResponse.\n *\n * @param response - Response from a fetch call\n */\nfunction processStream(response) {\n    const inputStream = response.body.pipeThrough(new TextDecoderStream(\"utf8\", { fatal: true }));\n    const responseStream = getResponseStream(inputStream);\n    const [stream1, stream2] = responseStream.tee();\n    return {\n        stream: generateResponseSequence(stream1),\n        response: getResponsePromise(stream2),\n    };\n}\nasync function getResponsePromise(stream) {\n    const allResponses = [];\n    const reader = stream.getReader();\n    while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n            return addHelpers(aggregateResponses(allResponses));\n        }\n        allResponses.push(value);\n    }\n}\nfunction generateResponseSequence(stream) {\n    return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {\n        const reader = stream.getReader();\n        while (true) {\n            const { value, done } = yield __await(reader.read());\n            if (done) {\n                break;\n            }\n            yield yield __await(addHelpers(value));\n        }\n    });\n}\n/**\n * Reads a raw stream from the fetch response and join incomplete\n * chunks, returning a new stream that provides a single complete\n * GenerateContentResponse in each iteration.\n */\nfunction getResponseStream(inputStream) {\n    const reader = inputStream.getReader();\n    const stream = new ReadableStream({\n        start(controller) {\n            let currentText = \"\";\n            return pump();\n            function pump() {\n                return reader\n                    .read()\n                    .then(({ value, done }) => {\n                    if (done) {\n                        if (currentText.trim()) {\n                            controller.error(new GoogleGenerativeAIError(\"Failed to parse stream\"));\n                            return;\n                        }\n                        controller.close();\n                        return;\n                    }\n                    currentText += value;\n                    let match = currentText.match(responseLineRE);\n                    let parsedResponse;\n                    while (match) {\n                        try {\n                            parsedResponse = JSON.parse(match[1]);\n                        }\n                        catch (e) {\n                            controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: \"${match[1]}\"`));\n                            return;\n                        }\n                        controller.enqueue(parsedResponse);\n                        currentText = currentText.substring(match[0].length);\n                        match = currentText.match(responseLineRE);\n                    }\n                    return pump();\n                })\n                    .catch((e) => {\n                    let err = e;\n                    err.stack = e.stack;\n                    if (err.name === \"AbortError\") {\n                        err = new GoogleGenerativeAIAbortError(\"Request aborted when reading from the stream\");\n                    }\n                    else {\n                        err = new GoogleGenerativeAIError(\"Error reading from the stream\");\n                    }\n                    throw err;\n                });\n            }\n        },\n    });\n    return stream;\n}\n/**\n * Aggregates an array of `GenerateContentResponse`s into a single\n * GenerateContentResponse.\n */\nfunction aggregateResponses(responses) {\n    const lastResponse = responses[responses.length - 1];\n    const aggregatedResponse = {\n        promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback,\n    };\n    for (const response of responses) {\n        if (response.candidates) {\n            let candidateIndex = 0;\n            for (const candidate of response.candidates) {\n                if (!aggregatedResponse.candidates) {\n                    aggregatedResponse.candidates = [];\n                }\n                if (!aggregatedResponse.candidates[candidateIndex]) {\n                    aggregatedResponse.candidates[candidateIndex] = {\n                        index: candidateIndex,\n                    };\n                }\n                // Keep overwriting, the last one will be final\n                aggregatedResponse.candidates[candidateIndex].citationMetadata =\n                    candidate.citationMetadata;\n                aggregatedResponse.candidates[candidateIndex].groundingMetadata =\n                    candidate.groundingMetadata;\n                aggregatedResponse.candidates[candidateIndex].finishReason =\n                    candidate.finishReason;\n                aggregatedResponse.candidates[candidateIndex].finishMessage =\n                    candidate.finishMessage;\n                aggregatedResponse.candidates[candidateIndex].safetyRatings =\n                    candidate.safetyRatings;\n                /**\n                 * Candidates should always have content and parts, but this handles\n                 * possible malformed responses.\n                 */\n                if (candidate.content && candidate.content.parts) {\n                    if (!aggregatedResponse.candidates[candidateIndex].content) {\n                        aggregatedResponse.candidates[candidateIndex].content = {\n                            role: candidate.content.role || \"user\",\n                            parts: [],\n                        };\n                    }\n                    const newPart = {};\n                    for (const part of candidate.content.parts) {\n                        if (part.text) {\n                            newPart.text = part.text;\n                        }\n                        if (part.functionCall) {\n                            newPart.functionCall = part.functionCall;\n                        }\n                        if (part.executableCode) {\n                            newPart.executableCode = part.executableCode;\n                        }\n                        if (part.codeExecutionResult) {\n                            newPart.codeExecutionResult = part.codeExecutionResult;\n                        }\n                        if (Object.keys(newPart).length === 0) {\n                            newPart.text = \"\";\n                        }\n                        aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);\n                    }\n                }\n            }\n            candidateIndex++;\n        }\n        if (response.usageMetadata) {\n            aggregatedResponse.usageMetadata = response.usageMetadata;\n        }\n    }\n    return aggregatedResponse;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function generateContentStream(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.STREAM_GENERATE_CONTENT, apiKey, \n    /* stream */ true, JSON.stringify(params), requestOptions);\n    return processStream(response);\n}\nasync function generateContent(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.GENERATE_CONTENT, apiKey, \n    /* stream */ false, JSON.stringify(params), requestOptions);\n    const responseJson = await response.json();\n    const enhancedResponse = addHelpers(responseJson);\n    return {\n        response: enhancedResponse,\n    };\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction formatSystemInstruction(input) {\n    // null or undefined\n    if (input == null) {\n        return undefined;\n    }\n    else if (typeof input === \"string\") {\n        return { role: \"system\", parts: [{ text: input }] };\n    }\n    else if (input.text) {\n        return { role: \"system\", parts: [input] };\n    }\n    else if (input.parts) {\n        if (!input.role) {\n            return { role: \"system\", parts: input.parts };\n        }\n        else {\n            return input;\n        }\n    }\n}\nfunction formatNewContent(request) {\n    let newParts = [];\n    if (typeof request === \"string\") {\n        newParts = [{ text: request }];\n    }\n    else {\n        for (const partOrString of request) {\n            if (typeof partOrString === \"string\") {\n                newParts.push({ text: partOrString });\n            }\n            else {\n                newParts.push(partOrString);\n            }\n        }\n    }\n    return assignRoleToPartsAndValidateSendMessageRequest(newParts);\n}\n/**\n * When multiple Part types (i.e. FunctionResponsePart and TextPart) are\n * passed in a single Part array, we may need to assign different roles to each\n * part. Currently only FunctionResponsePart requires a role other than 'user'.\n * @private\n * @param parts Array of parts to pass to the model\n * @returns Array of content items\n */\nfunction assignRoleToPartsAndValidateSendMessageRequest(parts) {\n    const userContent = { role: \"user\", parts: [] };\n    const functionContent = { role: \"function\", parts: [] };\n    let hasUserContent = false;\n    let hasFunctionContent = false;\n    for (const part of parts) {\n        if (\"functionResponse\" in part) {\n            functionContent.parts.push(part);\n            hasFunctionContent = true;\n        }\n        else {\n            userContent.parts.push(part);\n            hasUserContent = true;\n        }\n    }\n    if (hasUserContent && hasFunctionContent) {\n        throw new GoogleGenerativeAIError(\"Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.\");\n    }\n    if (!hasUserContent && !hasFunctionContent) {\n        throw new GoogleGenerativeAIError(\"No content is provided for sending chat message.\");\n    }\n    if (hasUserContent) {\n        return userContent;\n    }\n    return functionContent;\n}\nfunction formatCountTokensInput(params, modelParams) {\n    var _a;\n    let formattedGenerateContentRequest = {\n        model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,\n        generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,\n        safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,\n        tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,\n        toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,\n        systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,\n        cachedContent: (_a = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a === void 0 ? void 0 : _a.name,\n        contents: [],\n    };\n    const containsGenerateContentRequest = params.generateContentRequest != null;\n    if (params.contents) {\n        if (containsGenerateContentRequest) {\n            throw new GoogleGenerativeAIRequestInputError(\"CountTokensRequest must have one of contents or generateContentRequest, not both.\");\n        }\n        formattedGenerateContentRequest.contents = params.contents;\n    }\n    else if (containsGenerateContentRequest) {\n        formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);\n    }\n    else {\n        // Array or string\n        const content = formatNewContent(params);\n        formattedGenerateContentRequest.contents = [content];\n    }\n    return { generateContentRequest: formattedGenerateContentRequest };\n}\nfunction formatGenerateContentInput(params) {\n    let formattedRequest;\n    if (params.contents) {\n        formattedRequest = params;\n    }\n    else {\n        // Array or string\n        const content = formatNewContent(params);\n        formattedRequest = { contents: [content] };\n    }\n    if (params.systemInstruction) {\n        formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);\n    }\n    return formattedRequest;\n}\nfunction formatEmbedContentInput(params) {\n    if (typeof params === \"string\" || Array.isArray(params)) {\n        const content = formatNewContent(params);\n        return { content };\n    }\n    return params;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// https://ai.google.dev/api/rest/v1beta/Content#part\nconst VALID_PART_FIELDS = [\n    \"text\",\n    \"inlineData\",\n    \"functionCall\",\n    \"functionResponse\",\n    \"executableCode\",\n    \"codeExecutionResult\",\n];\nconst VALID_PARTS_PER_ROLE = {\n    user: [\"text\", \"inlineData\"],\n    function: [\"functionResponse\"],\n    model: [\"text\", \"functionCall\", \"executableCode\", \"codeExecutionResult\"],\n    // System instructions shouldn't be in history anyway.\n    system: [\"text\"],\n};\nfunction validateChatHistory(history) {\n    let prevContent = false;\n    for (const currContent of history) {\n        const { role, parts } = currContent;\n        if (!prevContent && role !== \"user\") {\n            throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);\n        }\n        if (!POSSIBLE_ROLES.includes(role)) {\n            throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);\n        }\n        if (!Array.isArray(parts)) {\n            throw new GoogleGenerativeAIError(\"Content should have 'parts' property with an array of Parts\");\n        }\n        if (parts.length === 0) {\n            throw new GoogleGenerativeAIError(\"Each Content should have at least one part\");\n        }\n        const countFields = {\n            text: 0,\n            inlineData: 0,\n            functionCall: 0,\n            functionResponse: 0,\n            fileData: 0,\n            executableCode: 0,\n            codeExecutionResult: 0,\n        };\n        for (const part of parts) {\n            for (const key of VALID_PART_FIELDS) {\n                if (key in part) {\n                    countFields[key] += 1;\n                }\n            }\n        }\n        const validParts = VALID_PARTS_PER_ROLE[role];\n        for (const key of VALID_PART_FIELDS) {\n            if (!validParts.includes(key) && countFields[key] > 0) {\n                throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);\n            }\n        }\n        prevContent = true;\n    }\n}\n/**\n * Returns true if the response is valid (could be appended to the history), flase otherwise.\n */\nfunction isValidResponse(response) {\n    var _a;\n    if (response.candidates === undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts) {\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n        if (part.text !== undefined && part.text === \"\") {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do not log a message for this error.\n */\nconst SILENT_ERROR = \"SILENT_ERROR\";\n/**\n * ChatSession class that enables sending chat messages and stores\n * history of sent and received messages so far.\n *\n * @public\n */\nclass ChatSession {\n    constructor(apiKey, model, params, _requestOptions = {}) {\n        this.model = model;\n        this.params = params;\n        this._requestOptions = _requestOptions;\n        this._history = [];\n        this._sendPromise = Promise.resolve();\n        this._apiKey = apiKey;\n        if (params === null || params === void 0 ? void 0 : params.history) {\n            validateChatHistory(params.history);\n            this._history = params.history;\n        }\n    }\n    /**\n     * Gets the chat history so far. Blocked prompts are not added to history.\n     * Blocked candidates are not added to history, nor are the prompts that\n     * generated them.\n     */\n    async getHistory() {\n        await this._sendPromise;\n        return this._history;\n    }\n    /**\n     * Sends a chat message and receives a non-streaming\n     * {@link GenerateContentResult}.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async sendMessage(request, requestOptions = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        await this._sendPromise;\n        const newContent = formatNewContent(request);\n        const generateContentRequest = {\n            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,\n            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,\n            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,\n            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,\n            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,\n            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,\n            contents: [...this._history, newContent],\n        };\n        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        let finalResult;\n        // Add onto the chain.\n        this._sendPromise = this._sendPromise\n            .then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions))\n            .then((result) => {\n            var _a;\n            if (isValidResponse(result.response)) {\n                this._history.push(newContent);\n                const responseContent = Object.assign({ parts: [], \n                    // Response seems to come back without a role set.\n                    role: \"model\" }, (_a = result.response.candidates) === null || _a === void 0 ? void 0 : _a[0].content);\n                this._history.push(responseContent);\n            }\n            else {\n                const blockErrorMessage = formatBlockErrorMessage(result.response);\n                if (blockErrorMessage) {\n                    console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);\n                }\n            }\n            finalResult = result;\n        })\n            .catch((e) => {\n            // Resets _sendPromise to avoid subsequent calls failing and throw error.\n            this._sendPromise = Promise.resolve();\n            throw e;\n        });\n        await this._sendPromise;\n        return finalResult;\n    }\n    /**\n     * Sends a chat message and receives the response as a\n     * {@link GenerateContentStreamResult} containing an iterable stream\n     * and a response promise.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async sendMessageStream(request, requestOptions = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        await this._sendPromise;\n        const newContent = formatNewContent(request);\n        const generateContentRequest = {\n            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,\n            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,\n            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,\n            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,\n            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,\n            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,\n            contents: [...this._history, newContent],\n        };\n        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);\n        // Add onto the chain.\n        this._sendPromise = this._sendPromise\n            .then(() => streamPromise)\n            // This must be handled to avoid unhandled rejection, but jump\n            // to the final catch block with a label to not log this error.\n            .catch((_ignored) => {\n            throw new Error(SILENT_ERROR);\n        })\n            .then((streamResult) => streamResult.response)\n            .then((response) => {\n            if (isValidResponse(response)) {\n                this._history.push(newContent);\n                const responseContent = Object.assign({}, response.candidates[0].content);\n                // Response seems to come back without a role set.\n                if (!responseContent.role) {\n                    responseContent.role = \"model\";\n                }\n                this._history.push(responseContent);\n            }\n            else {\n                const blockErrorMessage = formatBlockErrorMessage(response);\n                if (blockErrorMessage) {\n                    console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);\n                }\n            }\n        })\n            .catch((e) => {\n            // Errors in streamPromise are already catchable by the user as\n            // streamPromise is returned.\n            // Avoid duplicating the error message in logs.\n            if (e.message !== SILENT_ERROR) {\n                // Users do not have access to _sendPromise to catch errors\n                // downstream from streamPromise, so they should not throw.\n                console.error(e);\n            }\n        });\n        return streamPromise;\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function countTokens(apiKey, model, params, singleRequestOptions) {\n    const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);\n    return response.json();\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function embedContent(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);\n    return response.json();\n}\nasync function batchEmbedContents(apiKey, model, params, requestOptions) {\n    const requestsWithModel = params.requests.map((request) => {\n        return Object.assign(Object.assign({}, request), { model });\n    });\n    const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);\n    return response.json();\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class for generative model APIs.\n * @public\n */\nclass GenerativeModel {\n    constructor(apiKey, modelParams, _requestOptions = {}) {\n        this.apiKey = apiKey;\n        this._requestOptions = _requestOptions;\n        if (modelParams.model.includes(\"/\")) {\n            // Models may be named \"models/model-name\" or \"tunedModels/model-name\"\n            this.model = modelParams.model;\n        }\n        else {\n            // If path is not included, assume it's a non-tuned model.\n            this.model = `models/${modelParams.model}`;\n        }\n        this.generationConfig = modelParams.generationConfig || {};\n        this.safetySettings = modelParams.safetySettings || [];\n        this.tools = modelParams.tools;\n        this.toolConfig = modelParams.toolConfig;\n        this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);\n        this.cachedContent = modelParams.cachedContent;\n    }\n    /**\n     * Makes a single non-streaming call to the model\n     * and returns an object containing a single {@link GenerateContentResponse}.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async generateContent(request, requestOptions = {}) {\n        var _a;\n        const formattedParams = formatGenerateContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);\n    }\n    /**\n     * Makes a single streaming call to the model and returns an object\n     * containing an iterable stream that iterates over all chunks in the\n     * streaming response as well as a promise that returns the final\n     * aggregated response.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async generateContentStream(request, requestOptions = {}) {\n        var _a;\n        const formattedParams = formatGenerateContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);\n    }\n    /**\n     * Gets a new {@link ChatSession} instance which can be used for\n     * multi-turn chats.\n     */\n    startChat(startChatParams) {\n        var _a;\n        return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, startChatParams), this._requestOptions);\n    }\n    /**\n     * Counts the tokens in the provided request.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async countTokens(request, requestOptions = {}) {\n        const formattedParams = formatCountTokensInput(request, {\n            model: this.model,\n            generationConfig: this.generationConfig,\n            safetySettings: this.safetySettings,\n            tools: this.tools,\n            toolConfig: this.toolConfig,\n            systemInstruction: this.systemInstruction,\n            cachedContent: this.cachedContent,\n        });\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);\n    }\n    /**\n     * Embeds the provided content.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async embedContent(request, requestOptions = {}) {\n        const formattedParams = formatEmbedContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);\n    }\n    /**\n     * Embeds an array of {@link EmbedContentRequest}s.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided to\n     * {@link GoogleGenerativeAI.getGenerativeModel }.\n     */\n    async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Top-level class for this SDK\n * @public\n */\nclass GoogleGenerativeAI {\n    constructor(apiKey) {\n        this.apiKey = apiKey;\n    }\n    /**\n     * Gets a {@link GenerativeModel} instance for the provided model name.\n     */\n    getGenerativeModel(modelParams, requestOptions) {\n        if (!modelParams.model) {\n            throw new GoogleGenerativeAIError(`Must provide a model name. ` +\n                `Example: genai.getGenerativeModel({ model: 'my-model-name' })`);\n        }\n        return new GenerativeModel(this.apiKey, modelParams, requestOptions);\n    }\n    /**\n     * Creates a {@link GenerativeModel} instance from provided content cache.\n     */\n    getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {\n        if (!cachedContent.name) {\n            throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `name` field.\");\n        }\n        if (!cachedContent.model) {\n            throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `model` field.\");\n        }\n        /**\n         * Not checking tools and toolConfig for now as it would require a deep\n         * equality comparison and isn't likely to be a common case.\n         */\n        const disallowedDuplicates = [\"model\", \"systemInstruction\"];\n        for (const key of disallowedDuplicates) {\n            if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) &&\n                cachedContent[key] &&\n                (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {\n                if (key === \"model\") {\n                    const modelParamsComp = modelParams.model.startsWith(\"models/\")\n                        ? modelParams.model.replace(\"models/\", \"\")\n                        : modelParams.model;\n                    const cachedContentComp = cachedContent.model.startsWith(\"models/\")\n                        ? cachedContent.model.replace(\"models/\", \"\")\n                        : cachedContent.model;\n                    if (modelParamsComp === cachedContentComp) {\n                        continue;\n                    }\n                }\n                throw new GoogleGenerativeAIRequestInputError(`Different value for \"${key}\" specified in modelParams` +\n                    ` (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);\n            }\n        }\n        const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });\n        return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);\n    }\n}\n\nexport { BlockReason, ChatSession, DynamicRetrievalMode, ExecutableCodeLanguage, FinishReason, FunctionCallingMode, GenerativeModel, GoogleGenerativeAI, GoogleGenerativeAIAbortError, GoogleGenerativeAIError, GoogleGenerativeAIFetchError, GoogleGenerativeAIRequestInputError, GoogleGenerativeAIResponseError, HarmBlockThreshold, HarmCategory, HarmProbability, Outcome, POSSIBLE_ROLES, SchemaType, TaskType };\n//# sourceMappingURL=index.mjs.map\n","// src/background/config.ts\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ErrorFactory, ErrorLogger, withErrorHandling, withTimeout } from '../utils/errors';\n/**\n * Valida o formato da API key do Google Gemini\n * @param apiKey - A API key para validar\n * @throws {ValidationError} Se a API key for inválida\n */\nfunction validateApiKey(apiKey) {\n    if (!apiKey || typeof apiKey !== 'string') {\n        throw ErrorFactory.validationFailure('apiKey', apiKey, 'API key deve ser uma string não vazia');\n    }\n    const trimmedKey = apiKey.trim();\n    if (trimmedKey.length === 0) {\n        throw ErrorFactory.validationFailure('apiKey', apiKey, 'API key não pode estar vazia');\n    }\n    if (!trimmedKey.startsWith('AIza')) {\n        throw ErrorFactory.invalidApiKey(trimmedKey);\n    }\n    if (trimmedKey.length < 35) {\n        throw ErrorFactory.invalidApiKey(trimmedKey);\n    }\n}\n/**\n * Obtém a API key do Gemini do storage seguro\n * @returns Promise com a API key ou null se não configurada\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nexport function getGeminiApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield chrome.storage.sync.get(['geminiApiKey']);\n                return result.geminiApiKey || null;\n            }), 5000, 'getGeminiApiKey');\n        }), (error) => ErrorFactory.storageFailure('get', error));\n    });\n}\n/**\n * Salva a API key do Gemini no storage seguro\n * @param apiKey - A API key para salvar\n * @throws {ValidationError} Se a API key for inválida\n * @throws {StorageError} Se houver erro ao salvar no storage\n */\nexport function setGeminiApiKey(apiKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Valida a API key antes de salvar\n        validateApiKey(apiKey);\n        yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                yield chrome.storage.sync.set({\n                    geminiApiKey: apiKey.trim(),\n                    lastUpdated: Date.now()\n                });\n            }), 5000, 'setGeminiApiKey');\n        }), (error) => ErrorFactory.storageFailure('set', error));\n    });\n}\n/**\n * Remove a API key do storage\n * @throws {StorageError} Se houver erro ao remover do storage\n */\nexport function clearGeminiApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                yield chrome.storage.sync.remove(['geminiApiKey', 'lastUpdated']);\n            }), 5000, 'clearGeminiApiKey');\n        }), (error) => ErrorFactory.storageFailure('remove', error));\n    });\n}\n/**\n * Verifica se a API key está configurada\n * @returns Promise<boolean> - true se a API key está configurada\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nexport function isApiKeyConfigured() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const apiKey = yield getGeminiApiKey();\n            return apiKey !== null && apiKey.length > 0;\n        }\n        catch (error) {\n            // Se houver erro ao acessar storage, assumimos que não está configurada\n            ErrorLogger.log(error);\n            return false;\n        }\n    });\n}\n/**\n * Obtém configurações completas da extensão\n * @returns Promise<ExtensionConfig> - Configurações da extensão\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nexport function getExtensionConfig() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            return withTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield chrome.storage.sync.get(['geminiApiKey', 'lastUpdated']);\n                return {\n                    geminiApiKey: result.geminiApiKey || undefined,\n                    lastUpdated: result.lastUpdated || undefined\n                };\n            }), 5000, 'getExtensionConfig');\n        }), (error) => ErrorFactory.storageFailure('get', error));\n    });\n}\n","// src/utils/cache.ts - Sistema de cache inteligente para performance\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ErrorFactory, ErrorLogger, withErrorHandling } from './errors';\n/**\n * Estratégias de eviction do cache\n */\nexport var EvictionStrategy;\n(function (EvictionStrategy) {\n    EvictionStrategy[\"LRU\"] = \"lru\";\n    EvictionStrategy[\"LFU\"] = \"lfu\";\n    EvictionStrategy[\"TTL\"] = \"ttl\";\n})(EvictionStrategy || (EvictionStrategy = {}));\n/**\n * Sistema de cache inteligente com múltiplas estratégias\n */\nexport class IntelligentCache {\n    constructor(config = {}) {\n        this.cache = new Map();\n        this.currentSize = 0;\n        this.config = Object.assign({ maxSize: 10 * 1024 * 1024, maxItems: 1000, defaultTtl: 30 * 60 * 1000, cleanupInterval: 5 * 60 * 1000 }, config);\n        this.startCleanupTimer();\n    }\n    /**\n     * Adiciona item ao cache\n     */\n    set(key, data, ttl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n                const now = Date.now();\n                const itemTtl = ttl || this.config.defaultTtl;\n                const size = this.estimateSize(data);\n                // Remove item existente se houver\n                if (this.cache.has(key)) {\n                    this.remove(key);\n                }\n                // Verifica se precisa fazer eviction\n                yield this.ensureSpace(size);\n                const item = {\n                    data,\n                    timestamp: now,\n                    ttl: itemTtl,\n                    accessCount: 0,\n                    lastAccessed: now,\n                    size,\n                };\n                this.cache.set(key, item);\n                this.currentSize += size;\n                // Persiste no storage se necessário\n                yield this.persistToStorage(key, item);\n            }), (error) => ErrorFactory.storageFailure('cache_set', error));\n        });\n    }\n    /**\n     * Recupera item do cache\n     */\n    get(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n                let item = this.cache.get(key);\n                // Se não está na memória, tenta carregar do storage\n                if (!item) {\n                    const storageItem = yield this.loadFromStorage(key);\n                    if (storageItem) {\n                        item = storageItem;\n                        this.cache.set(key, item);\n                        this.currentSize += item.size || 0;\n                    }\n                }\n                if (!item) {\n                    return null;\n                }\n                // Verifica se expirou\n                const now = Date.now();\n                if (now - item.timestamp > item.ttl) {\n                    this.remove(key);\n                    return null;\n                }\n                // Atualiza estatísticas de acesso\n                item.accessCount++;\n                item.lastAccessed = now;\n                return item.data;\n            }), (error) => ErrorFactory.storageFailure('cache_get', error.message || 'Cache get failed'));\n        });\n    }\n    /**\n     * Remove item do cache\n     */\n    remove(key) {\n        const item = this.cache.get(key);\n        if (item) {\n            this.cache.delete(key);\n            this.currentSize -= item.size || 0;\n            this.removeFromStorage(key);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Limpa todo o cache\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.cache.clear();\n            this.currentSize = 0;\n            yield this.clearStorage();\n        });\n    }\n    /**\n     * Verifica se item existe e não expirou\n     */\n    has(key) {\n        const item = this.cache.get(key);\n        if (!item)\n            return false;\n        const now = Date.now();\n        if (now - item.timestamp > item.ttl) {\n            this.remove(key);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Obtém estatísticas do cache\n     */\n    getStats() {\n        const items = Array.from(this.cache.values());\n        const totalAccess = items.reduce((sum, item) => sum + item.accessCount, 0);\n        const totalPossibleAccess = items.length * Math.max(...items.map(i => i.accessCount), 1);\n        return {\n            size: this.currentSize,\n            itemCount: this.cache.size,\n            hitRate: totalPossibleAccess > 0 ? totalAccess / totalPossibleAccess : 0,\n            memoryUsage: this.currentSize / this.config.maxSize,\n            oldestItem: Math.min(...items.map(i => i.timestamp), Date.now()),\n            newestItem: Math.max(...items.map(i => i.timestamp), 0),\n        };\n    }\n    /**\n     * Força limpeza do cache\n     */\n    cleanup() {\n        const now = Date.now();\n        const keysToRemove = [];\n        for (const [key, item] of this.cache.entries()) {\n            if (now - item.timestamp > item.ttl) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.forEach(key => this.remove(key));\n    }\n    /**\n     * Garante que há espaço suficiente no cache\n     */\n    ensureSpace(requiredSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Se já tem espaço, não faz nada\n            if (this.currentSize + requiredSize <= this.config.maxSize &&\n                this.cache.size < this.config.maxItems) {\n                return;\n            }\n            // Executa estratégias de eviction\n            yield this.evictItems(requiredSize);\n        });\n    }\n    /**\n     * Remove itens usando estratégias de eviction\n     */\n    evictItems(requiredSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const items = Array.from(this.cache.entries());\n            // Ordena por estratégia LRU (menos recentemente usado)\n            items.sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);\n            let freedSpace = 0;\n            for (const [key] of items) {\n                if (freedSpace >= requiredSize && this.cache.size < this.config.maxItems) {\n                    break;\n                }\n                const item = this.cache.get(key);\n                if (item) {\n                    freedSpace += item.size || 0;\n                    this.remove(key);\n                }\n            }\n        });\n    }\n    /**\n     * Estima o tamanho de um objeto em bytes\n     */\n    estimateSize(data) {\n        try {\n            return new Blob([JSON.stringify(data)]).size;\n        }\n        catch (_a) {\n            // Fallback para estimativa simples\n            return JSON.stringify(data).length * 2; // UTF-16\n        }\n    }\n    /**\n     * Persiste item no storage\n     */\n    persistToStorage(key, item) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const storageKey = `cache_${key}`;\n                yield chrome.storage.local.set({ [storageKey]: item });\n            }\n            catch (error) {\n                // Falha silenciosa - cache funciona apenas na memória\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_persist', error));\n            }\n        });\n    }\n    /**\n     * Carrega item do storage\n     */\n    loadFromStorage(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const storageKey = `cache_${key}`;\n                const result = yield chrome.storage.local.get([storageKey]);\n                return result[storageKey] || null;\n            }\n            catch (error) {\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_load', error));\n                return null;\n            }\n        });\n    }\n    /**\n     * Remove item do storage\n     */\n    removeFromStorage(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const storageKey = `cache_${key}`;\n                yield chrome.storage.local.remove([storageKey]);\n            }\n            catch (error) {\n                // Falha silenciosa\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_remove', error));\n            }\n        });\n    }\n    /**\n     * Limpa todo o storage do cache\n     */\n    clearStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield chrome.storage.local.get(null);\n                const cacheKeys = Object.keys(result).filter(key => key.startsWith('cache_'));\n                if (cacheKeys.length > 0) {\n                    yield chrome.storage.local.remove(cacheKeys);\n                }\n            }\n            catch (error) {\n                ErrorLogger.log(ErrorFactory.storageFailure('cache_clear', error));\n            }\n        });\n    }\n    /**\n     * Inicia timer de limpeza automática\n     */\n    startCleanupTimer() {\n        this.cleanupTimer = setInterval(() => {\n            this.cleanup();\n        }, this.config.cleanupInterval);\n    }\n    /**\n     * Para timer de limpeza\n     */\n    destroy() {\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n}\n/**\n * Cache específico para respostas da IA\n */\nexport class AIResponseCache extends IntelligentCache {\n    constructor() {\n        super({\n            maxSize: 5 * 1024 * 1024, // 5MB para respostas da IA\n            maxItems: 100,\n            defaultTtl: 60 * 60 * 1000, // 1 hora\n        });\n    }\n    /**\n     * Gera chave de cache baseada no contexto e prompt\n     */\n    generateKey(context, prompt) {\n        const combined = `${context}_${prompt}`;\n        return this.hashString(combined);\n    }\n    /**\n     * Hash simples para gerar chaves\n     */\n    hashString(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32-bit integer\n        }\n        return Math.abs(hash).toString(36);\n    }\n}\n/**\n * Cache para contextos de página\n */\nexport class PageContextCache extends IntelligentCache {\n    constructor() {\n        super({\n            maxSize: 2 * 1024 * 1024, // 2MB para contextos\n            maxItems: 50,\n            defaultTtl: 10 * 60 * 1000, // 10 minutos\n        });\n    }\n    /**\n     * Gera chave baseada na URL e hash do conteúdo\n     */\n    generateKey(url, contentHash) {\n        return `${url}_${contentHash}`;\n    }\n}\n// Instâncias globais dos caches\nexport const aiResponseCache = new AIResponseCache();\nexport const pageContextCache = new PageContextCache();\n","// src/utils/errors.ts - Sistema de tratamento de erros personalizado\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Classe base para erros da extensão\n */\nexport class ExtensionError extends Error {\n    constructor(message, context) {\n        super(message);\n        this.name = this.constructor.name;\n        this.timestamp = Date.now();\n        this.context = context;\n        // Mantém o stack trace correto\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    /**\n     * Converte o erro para um objeto serializável\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            code: this.code,\n            message: this.message,\n            userMessage: this.userMessage,\n            timestamp: this.timestamp,\n            context: this.context,\n            stack: this.stack,\n        };\n    }\n}\n/**\n * Erro relacionado à configuração da API key\n */\nexport class ApiKeyError extends ExtensionError {\n    constructor(message, userMessage, context) {\n        super(message, context);\n        this.userMessage = userMessage;\n        this.code = 'API_KEY_ERROR';\n    }\n}\n/**\n * Erro de comunicação com a API do Gemini\n */\nexport class GeminiApiError extends ExtensionError {\n    constructor(message, userMessage, statusCode, context) {\n        super(message, Object.assign(Object.assign({}, context), { statusCode }));\n        this.userMessage = userMessage;\n        this.statusCode = statusCode;\n        this.code = 'GEMINI_API_ERROR';\n    }\n}\n/**\n * Erro de storage do Chrome\n */\nexport class StorageError extends ExtensionError {\n    constructor(message, userMessage, context) {\n        super(message, context);\n        this.userMessage = userMessage;\n        this.code = 'STORAGE_ERROR';\n    }\n}\n/**\n * Erro de captura de página\n */\nexport class PageCaptureError extends ExtensionError {\n    constructor(message, userMessage, context) {\n        super(message, context);\n        this.userMessage = userMessage;\n        this.code = 'PAGE_CAPTURE_ERROR';\n    }\n}\n/**\n * Erro de validação de dados\n */\nexport class ValidationError extends ExtensionError {\n    constructor(message, userMessage, field, context) {\n        super(message, Object.assign(Object.assign({}, context), { field }));\n        this.userMessage = userMessage;\n        this.field = field;\n        this.code = 'VALIDATION_ERROR';\n    }\n}\n/**\n * Erro de timeout\n */\nexport class TimeoutError extends ExtensionError {\n    constructor(message, userMessage, timeoutMs, context) {\n        super(message, Object.assign(Object.assign({}, context), { timeoutMs }));\n        this.userMessage = userMessage;\n        this.timeoutMs = timeoutMs;\n        this.code = 'TIMEOUT_ERROR';\n    }\n}\n/**\n * Utilitário para criar erros baseados em diferentes tipos de falha\n */\nexport class ErrorFactory {\n    static apiKeyNotConfigured() {\n        return new ApiKeyError('Gemini API key is not configured', 'API key do Gemini não configurada. Por favor, configure nas opções da extensão.', { action: 'configure_api_key' });\n    }\n    static invalidApiKey(key) {\n        return new ApiKeyError(`Invalid API key format: ${key.substring(0, 8)}...`, 'Formato de API key inválido. Verifique se você copiou a chave corretamente.', { keyPrefix: key.substring(0, 8) });\n    }\n    static geminiApiFailure(error, statusCode) {\n        const message = (error === null || error === void 0 ? void 0 : error.message) || 'Unknown Gemini API error';\n        let userMessage = 'Erro ao comunicar com a IA. Tente novamente em alguns momentos.';\n        if (statusCode === 429) {\n            userMessage = 'Muitas requisições. Aguarde um momento antes de tentar novamente.';\n        }\n        else if (statusCode === 401) {\n            userMessage = 'API key inválida. Verifique sua configuração.';\n        }\n        else if (statusCode === 403) {\n            userMessage = 'Acesso negado. Verifique se sua API key tem as permissões necessárias.';\n        }\n        return new GeminiApiError(message, userMessage, statusCode, { originalError: error });\n    }\n    static storageFailure(operation, error) {\n        return new StorageError(`Storage ${operation} failed: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`, 'Erro ao acessar configurações. Tente recarregar a extensão.', { operation, originalError: error });\n    }\n    static pageCaptureFailure(error) {\n        return new PageCaptureError(`Failed to capture page: ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`, 'Não foi possível capturar a página. Verifique se a página está carregada completamente.', { originalError: error });\n    }\n    static validationFailure(field, value, reason) {\n        return new ValidationError(`Validation failed for ${field}: ${reason}`, `Valor inválido para ${field}: ${reason}`, field, { value, reason });\n    }\n    static timeoutFailure(operation, timeoutMs) {\n        return new TimeoutError(`Operation ${operation} timed out after ${timeoutMs}ms`, 'Operação demorou muito para responder. Tente novamente.', timeoutMs, { operation });\n    }\n}\n/**\n * Logger centralizado para erros\n */\nexport class ErrorLogger {\n    /**\n     * Registra um erro no log\n     */\n    static log(error) {\n        this.logs.push({ error, timestamp: Date.now() });\n        // Mantém apenas os últimos MAX_LOGS\n        if (this.logs.length > this.MAX_LOGS) {\n            this.logs = this.logs.slice(-this.MAX_LOGS);\n        }\n        // Log no console para desenvolvimento\n        console.error(`[${error.code}] ${error.message}`, {\n            userMessage: error.userMessage,\n            context: error.context,\n            stack: error.stack,\n        });\n    }\n    /**\n     * Obtém todos os logs de erro\n     */\n    static getLogs() {\n        return [...this.logs];\n    }\n    /**\n     * Limpa todos os logs\n     */\n    static clearLogs() {\n        this.logs = [];\n    }\n    /**\n     * Obtém estatísticas dos erros\n     */\n    static getStats() {\n        const stats = {};\n        this.logs.forEach(({ error }) => {\n            stats[error.code] = (stats[error.code] || 0) + 1;\n        });\n        return stats;\n    }\n}\nErrorLogger.MAX_LOGS = 100;\nErrorLogger.logs = [];\n/**\n * Wrapper para operações assíncronas com tratamento de erro\n */\nexport function withErrorHandling(operation, errorFactory) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            return yield operation();\n        }\n        catch (error) {\n            // Se já é um ExtensionError (como TimeoutError), preserva o tipo original\n            if (error instanceof ExtensionError) {\n                ErrorLogger.log(error);\n                throw error;\n            }\n            const extensionError = errorFactory(error);\n            ErrorLogger.log(extensionError);\n            throw extensionError;\n        }\n    });\n}\n/**\n * Wrapper para operações com timeout\n */\nexport function withTimeout(operation, timeoutMs, operationName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const timer = setTimeout(() => {\n                const error = ErrorFactory.timeoutFailure(operationName, timeoutMs);\n                ErrorLogger.log(error);\n                reject(error);\n            }, timeoutMs);\n            operation()\n                .then(resolve)\n                .catch(reject)\n                .finally(() => clearTimeout(timer));\n        });\n    });\n}\n","// src/utils/fullPageCapture.ts - Sistema de Captura de Página Completa\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Captura as dimensões completas da página\n */\nexport function getPageDimensions(tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const results = yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: () => {\n                return {\n                    width: Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth),\n                    height: Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight),\n                    viewportWidth: window.innerWidth,\n                    viewportHeight: window.innerHeight,\n                    scrollWidth: document.documentElement.scrollWidth,\n                    scrollHeight: document.documentElement.scrollHeight\n                };\n            }\n        });\n        if (!((_a = results[0]) === null || _a === void 0 ? void 0 : _a.result)) {\n            throw new Error('Falha ao obter dimensões da página');\n        }\n        return results[0].result;\n    });\n}\n/**\n * Captura página completa usando abordagem mais simples e rápida\n * Minimiza o tempo de scroll para reduzir impacto visual\n */\nfunction captureFullPageWithoutScroll(tabId, windowId, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        // 1. Salvar posição atual do usuário\n        const originalPosition = yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: () => ({ x: window.scrollX, y: window.scrollY })\n        });\n        const originalScroll = ((_a = originalPosition[0]) === null || _a === void 0 ? void 0 : _a.result) || { x: 0, y: 0 };\n        // 2. Obter dimensões da página\n        const dimensions = yield getPageDimensions(tabId);\n        // 3. Calcular segmentos\n        const maxHeight = options.maxHeight || 8000;\n        const effectiveHeight = Math.min(dimensions.height, maxHeight);\n        const viewportHeight = dimensions.viewportHeight;\n        const segmentCount = Math.ceil(effectiveHeight / viewportHeight);\n        console.log(`[FullPageCapture] Capturando ${segmentCount} segmentos rapidamente...`);\n        const screenshots = [];\n        // 4. Capturar cada segmento respeitando rate limits do Chrome\n        for (let i = 0; i < segmentCount; i++) {\n            const yPosition = i * viewportHeight;\n            // Scroll instantâneo para a posição\n            yield chrome.scripting.executeScript({\n                target: { tabId },\n                func: (y) => {\n                    window.scrollTo({\n                        top: y,\n                        left: 0,\n                        behavior: 'instant'\n                    });\n                },\n                args: [yPosition]\n            });\n            // Aguardar renderização + rate limit (aumentado para evitar quota)\n            const waitTime = Math.max(200, options.waitTime || 200);\n            yield new Promise(resolve => setTimeout(resolve, waitTime));\n            try {\n                // Capturar screenshot com retry em caso de rate limit\n                const screenshot = yield chrome.tabs.captureVisibleTab(windowId, {\n                    format: options.format || 'jpeg',\n                    quality: options.quality || 70\n                });\n                if (!screenshot) {\n                    throw new Error(`Screenshot vazio para segmento ${i + 1}`);\n                }\n                screenshots.push(screenshot);\n                console.log(`[FullPageCapture] Segmento ${i + 1}/${segmentCount} capturado`);\n            }\n            catch (error) {\n                if (((_b = error === null || error === void 0 ? void 0 : error.message) === null || _b === void 0 ? void 0 : _b.includes('quota')) || ((_c = error === null || error === void 0 ? void 0 : error.message) === null || _c === void 0 ? void 0 : _c.includes('rate'))) {\n                    console.warn(`[FullPageCapture] Rate limit atingido, aguardando 1s...`);\n                    yield new Promise(resolve => setTimeout(resolve, 1000));\n                    // Retry uma vez\n                    try {\n                        const screenshot = yield chrome.tabs.captureVisibleTab(windowId, {\n                            format: options.format || 'jpeg',\n                            quality: options.quality || 70\n                        });\n                        if (!screenshot) {\n                            throw new Error(`Screenshot vazio para segmento ${i + 1} (retry)`);\n                        }\n                        screenshots.push(screenshot);\n                        console.log(`[FullPageCapture] Segmento ${i + 1}/${segmentCount} capturado (retry)`);\n                    }\n                    catch (retryError) {\n                        console.error(`[FullPageCapture] Falha no retry do segmento ${i + 1}:`, retryError);\n                        throw new Error(`Falha na captura do segmento ${i + 1}: ${retryError}`);\n                    }\n                }\n                else {\n                    console.error(`[FullPageCapture] Erro no segmento ${i + 1}:`, error);\n                    throw error;\n                }\n            }\n        }\n        // 5. Restaurar posição original IMEDIATAMENTE\n        yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: (pos) => {\n                window.scrollTo({\n                    top: pos.y,\n                    left: pos.x,\n                    behavior: 'instant'\n                });\n            },\n            args: [originalScroll]\n        });\n        console.log('[FullPageCapture] Posição original restaurada');\n        return screenshots;\n    });\n}\n/**\n * Une múltiplos screenshots usando OffscreenCanvas (funciona em background)\n */\nfunction stitchScreenshots(screenshots, dimensions, viewportHeight) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Usar OffscreenCanvas para funcionar em background script\n        const canvas = new OffscreenCanvas(dimensions.viewportWidth, Math.min(dimensions.height, screenshots.length * viewportHeight));\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('Não foi possível criar contexto do OffscreenCanvas');\n        }\n        // Carregar e desenhar todas as imagens\n        for (let i = 0; i < screenshots.length; i++) {\n            const screenshot = screenshots[i];\n            const yPosition = i * viewportHeight;\n            // Converter base64 para ImageBitmap\n            const response = yield fetch(screenshot);\n            const blob = yield response.blob();\n            const imageBitmap = yield createImageBitmap(blob);\n            // Desenhar no canvas\n            ctx.drawImage(imageBitmap, 0, yPosition);\n            // Limpar memória\n            imageBitmap.close();\n        }\n        // Converter para blob e depois para data URL\n        const blob = yield canvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = () => resolve(reader.result);\n            reader.onerror = () => reject(new Error('Erro ao converter blob para data URL'));\n            reader.readAsDataURL(blob);\n        });\n    });\n}\n/**\n * Extrai contexto HTML e texto da página completa\n */\nfunction extractFullPageContext(tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const results = yield chrome.scripting.executeScript({\n            target: { tabId },\n            func: () => {\n                // Função para extrair conteúdo relevante\n                const extractContent = () => {\n                    // Priorizar elementos principais de conteúdo\n                    const mainContentElement = document.querySelector('main') ||\n                        document.querySelector('article') ||\n                        document.querySelector('[role=\"main\"]') ||\n                        document.querySelector('.content') ||\n                        document.querySelector('#content') ||\n                        document.querySelector('ytd-two-column-browse-results-renderer') || // YouTube\n                        document.body;\n                    const bodyClone = mainContentElement.cloneNode(true);\n                    // Remover elementos desnecessários\n                    const elementsToRemove = [\n                        'script', 'style', 'svg', 'noscript', 'nav', 'footer',\n                        'aside', '#secondary', '.ads', '.advertisement',\n                        '[data-ad]', '.sidebar', '.menu'\n                    ];\n                    elementsToRemove.forEach(selector => {\n                        bodyClone.querySelectorAll(selector).forEach(el => el.remove());\n                    });\n                    // Extrair texto de elementos importantes\n                    const importantSelectors = [\n                        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n                        'p', 'article', 'section',\n                        '.title', '.heading', '.description',\n                        '[data-testid*=\"title\"]', '[data-testid*=\"description\"]'\n                    ];\n                    let structuredText = '';\n                    importantSelectors.forEach(selector => {\n                        const elements = bodyClone.querySelectorAll(selector);\n                        elements.forEach(el => {\n                            var _a;\n                            const text = (_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim();\n                            if (text && text.length > 10) {\n                                structuredText += `${selector.toUpperCase()}: ${text}\\n`;\n                            }\n                        });\n                    });\n                    return {\n                        title: document.title,\n                        htmlContent: bodyClone.innerHTML,\n                        textContent: bodyClone.innerText,\n                        structuredText: structuredText,\n                        url: window.location.href\n                    };\n                };\n                return extractContent();\n            }\n        });\n        if (!((_a = results[0]) === null || _a === void 0 ? void 0 : _a.result)) {\n            throw new Error('Falha ao extrair contexto da página');\n        }\n        const result = results[0].result;\n        return {\n            htmlContext: result.htmlContent,\n            textContext: result.structuredText || result.textContent,\n            title: result.title\n        };\n    });\n}\n/**\n * Função principal para capturar página completa SEM scroll visível\n */\nexport function captureFullPage(tabId_1, windowId_1) {\n    return __awaiter(this, arguments, void 0, function* (tabId, windowId, options = {}) {\n        const startTime = Date.now();\n        try {\n            // 1. Obter dimensões da página\n            console.log('[FullPageCapture] Obtendo dimensões da página...');\n            const dimensions = yield getPageDimensions(tabId);\n            // 2. Calcular quantos segmentos precisamos\n            const maxHeight = options.maxHeight || 8000;\n            const effectiveHeight = Math.min(dimensions.height, maxHeight);\n            const viewportHeight = dimensions.viewportHeight;\n            const segmentCount = Math.ceil(effectiveHeight / viewportHeight);\n            console.log(`[FullPageCapture] Página: ${dimensions.width}x${dimensions.height}px`);\n            console.log(`[FullPageCapture] Capturando ${segmentCount} segmentos SEM scroll visível...`);\n            // 3. Capturar todos os segmentos sem afetar o usuário\n            const screenshots = yield captureFullPageWithoutScroll(tabId, windowId, options);\n            // 4. Unir screenshots\n            console.log('[FullPageCapture] Unindo screenshots...');\n            const fullScreenshot = yield stitchScreenshots(screenshots, dimensions, viewportHeight);\n            // 5. Extrair contexto da página\n            console.log('[FullPageCapture] Extraindo contexto...');\n            const context = yield extractFullPageContext(tabId);\n            const result = {\n                screenshot: fullScreenshot,\n                dimensions,\n                htmlContext: context.htmlContext,\n                textContext: context.textContext,\n                title: context.title,\n                url: (yield chrome.tabs.get(tabId)).url || '',\n                captureTime: Date.now() - startTime,\n                segments: segmentCount\n            };\n            console.log(`[FullPageCapture] Captura completa em ${result.captureTime}ms SEM afetar o usuário`);\n            return result;\n        }\n        catch (error) {\n            console.error('[FullPageCapture] Erro durante captura:', error);\n            throw new Error(`Falha na captura de página completa: ${error}`);\n        }\n    });\n}\n/**\n * Função utilitária para comprimir screenshot se necessário\n */\nexport function compressScreenshot(dataUrl, maxSizeKB = 1024) {\n    // Se a imagem for menor que o limite, retorna como está\n    const sizeKB = (dataUrl.length * 3 / 4) / 1024; // Aproximação do tamanho em KB\n    if (sizeKB <= maxSizeKB) {\n        return dataUrl;\n    }\n    // Criar canvas para recompressão\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n    return new Promise((resolve) => {\n        img.onload = () => {\n            // Reduzir qualidade progressivamente até atingir o tamanho desejado\n            let quality = 0.8;\n            let compressed = dataUrl;\n            while (quality > 0.1) {\n                canvas.width = img.width;\n                canvas.height = img.height;\n                ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, 0, 0);\n                compressed = canvas.toDataURL('image/jpeg', quality);\n                const newSizeKB = (compressed.length * 3 / 4) / 1024;\n                if (newSizeKB <= maxSizeKB) {\n                    break;\n                }\n                quality -= 0.1;\n            }\n            resolve(compressed);\n        };\n        img.src = dataUrl;\n    }); // Type assertion para compatibilidade\n}\n","// src/utils/performance.ts - Sistema de otimizações de performance\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ErrorFactory, ErrorLogger } from './errors';\n/**\n * Debounce function para limitar chamadas frequentes\n */\nexport function debounce(func, delay) {\n    let timeoutId;\n    return (...args) => {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => func(...args), delay);\n    };\n}\n/**\n * Throttle function para limitar taxa de execução\n */\nexport function throttle(func, limit) {\n    let inThrottle;\n    return (...args) => {\n        if (!inThrottle) {\n            func(...args);\n            inThrottle = true;\n            setTimeout(() => inThrottle = false, limit);\n        }\n    };\n}\n/**\n * Memoização para funções puras\n */\nexport function memoize(func, getKey) {\n    const cache = new Map();\n    return ((...args) => {\n        const key = getKey ? getKey(...args) : JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = func(...args);\n        cache.set(key, result);\n        return result;\n    });\n}\n/**\n * Lazy loading para recursos pesados\n */\nexport class LazyLoader {\n    constructor(loader) {\n        this.promise = null;\n        this.result = null;\n        this.loader = loader;\n    }\n    load() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.result) {\n                return this.result;\n            }\n            if (!this.promise) {\n                this.promise = this.loader();\n            }\n            this.result = yield this.promise;\n            return this.result;\n        });\n    }\n    isLoaded() {\n        return this.result !== null;\n    }\n    reset() {\n        this.promise = null;\n        this.result = null;\n    }\n}\n/**\n * Pool de workers para processamento paralelo\n */\nexport class WorkerPool {\n    constructor(workerScript, poolSize = 4) {\n        this.workers = [];\n        this.availableWorkers = [];\n        this.taskQueue = [];\n        for (let i = 0; i < poolSize; i++) {\n            const worker = new Worker(workerScript);\n            this.workers.push(worker);\n            this.availableWorkers.push(worker);\n        }\n    }\n    execute(task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.taskQueue.push({ task, resolve, reject });\n                this.processQueue();\n            });\n        });\n    }\n    processQueue() {\n        if (this.taskQueue.length === 0 || this.availableWorkers.length === 0) {\n            return;\n        }\n        const worker = this.availableWorkers.pop();\n        const { task, resolve, reject } = this.taskQueue.shift();\n        const handleMessage = (event) => {\n            worker.removeEventListener('message', handleMessage);\n            worker.removeEventListener('error', handleError);\n            this.availableWorkers.push(worker);\n            resolve(event.data);\n            this.processQueue();\n        };\n        const handleError = (error) => {\n            worker.removeEventListener('message', handleMessage);\n            worker.removeEventListener('error', handleError);\n            this.availableWorkers.push(worker);\n            reject(error);\n            this.processQueue();\n        };\n        worker.addEventListener('message', handleMessage);\n        worker.addEventListener('error', handleError);\n        worker.postMessage(task);\n    }\n    destroy() {\n        this.workers.forEach(worker => worker.terminate());\n        this.workers = [];\n        this.availableWorkers = [];\n        this.taskQueue = [];\n    }\n}\n/**\n * Compressão de dados para reduzir uso de memória\n */\nexport class DataCompressor {\n    /**\n     * Comprime string usando algoritmo simples\n     */\n    static compress(data) {\n        try {\n            // Usa compressão simples baseada em repetições\n            return this.simpleCompress(data);\n        }\n        catch (error) {\n            ErrorLogger.log(ErrorFactory.validationFailure('compression', data, 'Failed to compress'));\n            return data; // Fallback para dados não comprimidos\n        }\n    }\n    /**\n     * Descomprime string\n     */\n    static decompress(compressedData) {\n        try {\n            return this.simpleDecompress(compressedData);\n        }\n        catch (error) {\n            ErrorLogger.log(ErrorFactory.validationFailure('decompression', compressedData, 'Failed to decompress'));\n            return compressedData; // Fallback\n        }\n    }\n    /**\n     * Compressão simples para fallback\n     */\n    static simpleCompress(data) {\n        const result = [];\n        let i = 0;\n        while (i < data.length) {\n            let count = 1;\n            const char = data[i];\n            while (i + count < data.length && data[i + count] === char && count < 255) {\n                count++;\n            }\n            if (count > 3) {\n                result.push(`${count}${char}`);\n            }\n            else {\n                result.push(char.repeat(count));\n            }\n            i += count;\n        }\n        return result.join('');\n    }\n    /**\n     * Descompressão simples\n     */\n    static simpleDecompress(data) {\n        return data.replace(/(\\d+)(.)/g, (match, count, char) => {\n            const num = parseInt(count, 10);\n            return num > 3 ? char.repeat(num) : match;\n        });\n    }\n}\n/**\n * Monitor de performance para métricas\n */\nexport class PerformanceMonitor {\n    constructor() {\n        this.metrics = new Map();\n    }\n    /**\n     * Mede tempo de execução de uma função\n     */\n    measure(name, fn) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const startTime = performance.now();\n            try {\n                const result = yield fn();\n                this.recordMetric(name, performance.now() - startTime);\n                return result;\n            }\n            catch (error) {\n                this.recordMetric(name, performance.now() - startTime, true);\n                throw error;\n            }\n        });\n    }\n    /**\n     * Registra métrica manualmente\n     */\n    recordMetric(name, time, isError = false) {\n        const existing = this.metrics.get(name) || {\n            count: 0,\n            totalTime: 0,\n            minTime: Infinity,\n            maxTime: 0,\n            lastTime: 0,\n        };\n        existing.count++;\n        existing.totalTime += time;\n        existing.minTime = Math.min(existing.minTime, time);\n        existing.maxTime = Math.max(existing.maxTime, time);\n        existing.lastTime = time;\n        this.metrics.set(name, existing);\n        // Log métricas críticas\n        if (time > 5000) { // Mais de 5 segundos\n            ErrorLogger.log(ErrorFactory.timeoutFailure(name, time));\n        }\n    }\n    /**\n     * Obtém estatísticas de performance\n     */\n    getStats() {\n        const stats = {};\n        for (const [name, metric] of this.metrics.entries()) {\n            stats[name] = {\n                count: metric.count,\n                avgTime: metric.totalTime / metric.count,\n                minTime: metric.minTime === Infinity ? 0 : metric.minTime,\n                maxTime: metric.maxTime,\n                lastTime: metric.lastTime,\n            };\n        }\n        return stats;\n    }\n    /**\n     * Limpa métricas antigas\n     */\n    clearStats() {\n        this.metrics.clear();\n    }\n}\n/**\n * Otimizador de imagens para reduzir tamanho\n */\nexport class ImageOptimizer {\n    /**\n     * Reduz qualidade de imagem base64\n     */\n    static optimizeBase64Image(base64Data, quality = 0.7, maxWidth = 1920, maxHeight = 1080) {\n        return new Promise((resolve) => {\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            const img = new Image();\n            img.onload = () => {\n                // Calcula dimensões otimizadas\n                let { width, height } = this.calculateOptimalDimensions(img.width, img.height, maxWidth, maxHeight);\n                canvas.width = width;\n                canvas.height = height;\n                // Desenha imagem redimensionada\n                ctx.drawImage(img, 0, 0, width, height);\n                // Converte para base64 com qualidade reduzida\n                const optimizedData = canvas.toDataURL('image/jpeg', quality);\n                resolve(optimizedData);\n            };\n            img.src = base64Data;\n        });\n    }\n    /**\n     * Calcula dimensões ótimas mantendo aspect ratio\n     */\n    static calculateOptimalDimensions(originalWidth, originalHeight, maxWidth, maxHeight) {\n        const aspectRatio = originalWidth / originalHeight;\n        let width = originalWidth;\n        let height = originalHeight;\n        if (width > maxWidth) {\n            width = maxWidth;\n            height = width / aspectRatio;\n        }\n        if (height > maxHeight) {\n            height = maxHeight;\n            width = height * aspectRatio;\n        }\n        return { width: Math.round(width), height: Math.round(height) };\n    }\n}\n/**\n * Batch processor para operações em lote\n */\nexport class BatchProcessor {\n    constructor(processor, batchSize = 10, delay = 100) {\n        this.queue = [];\n        this.processing = false;\n        this.processor = processor;\n        this.batchSize = batchSize;\n        this.delay = delay;\n    }\n    add(item) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.queue.push(item);\n                // Adiciona resolver para este item específico\n                const itemIndex = this.queue.length - 1;\n                setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.processing) {\n                        try {\n                            const results = yield this.processBatch();\n                            resolve(results[itemIndex]);\n                        }\n                        catch (error) {\n                            reject(error);\n                        }\n                    }\n                }), this.delay);\n            });\n        });\n    }\n    processBatch() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.processing || this.queue.length === 0) {\n                return [];\n            }\n            this.processing = true;\n            const batch = this.queue.splice(0, this.batchSize);\n            try {\n                const results = yield this.processor(batch);\n                return results;\n            }\n            finally {\n                this.processing = false;\n                // Processa próximo batch se houver itens na fila\n                if (this.queue.length > 0) {\n                    setTimeout(() => this.processBatch(), this.delay);\n                }\n            }\n        });\n    }\n}\n// Instâncias globais\nexport const performanceMonitor = new PerformanceMonitor();\n","// src/utils/webSearch.ts - Sistema de Pesquisa Web Inteligente\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Detecta se uma resposta da IA indica necessidade de pesquisa web\n */\nexport function needsWebSearch(aiResponse, userQuestion) {\n    const needsSearchIndicators = [\n        'não está aqui nesta página',\n        'não consigo encontrar',\n        'não está visível',\n        'preciso de mais informações',\n        'não tenho informações sobre',\n        'não está disponível na página',\n        'precisa pesquisar',\n        'informação não está presente',\n        'não posso ver',\n        'não está mostrado'\n    ];\n    const responseText = aiResponse.toLowerCase();\n    const questionText = userQuestion.toLowerCase();\n    // Verifica se a resposta indica falta de informação\n    const hasNeedsIndicator = needsSearchIndicators.some(indicator => responseText.includes(indicator));\n    // Verifica se a pergunta é sobre algo específico que pode precisar de busca\n    const isSpecificQuestion = [\n        'como', 'quando', 'onde', 'por que', 'quem', 'qual',\n        'preço', 'valor', 'custo', 'data', 'horário',\n        'contato', 'telefone', 'endereço', 'email',\n        'novidades', 'notícias', 'atualização'\n    ].some(keyword => questionText.includes(keyword));\n    return hasNeedsIndicator || (isSpecificQuestion && responseText.length < 200);\n}\n/**\n * Extrai termos de busca relevantes do contexto e pergunta do usuário\n */\nexport function extractSearchQuery(userQuestion, pageContext, pageUrl) {\n    // Limpar e normalizar a pergunta\n    let query = userQuestion.trim();\n    // Remover palavras de parada comuns\n    const stopWords = [\n        'o', 'a', 'os', 'as', 'um', 'uma', 'de', 'do', 'da', 'dos', 'das',\n        'em', 'no', 'na', 'nos', 'nas', 'para', 'por', 'com', 'sem',\n        'que', 'qual', 'quais', 'como', 'quando', 'onde', 'por que', 'porque',\n        'me', 'te', 'se', 'nos', 'vos', 'lhe', 'lhes',\n        'este', 'esta', 'estes', 'estas', 'esse', 'essa', 'esses', 'essas',\n        'aquele', 'aquela', 'aqueles', 'aquelas'\n    ];\n    // Extrair entidades importantes do contexto da página\n    const pageEntities = extractEntitiesFromContext(pageContext);\n    // Adicionar contexto relevante da página à busca\n    if (pageEntities.length > 0) {\n        const mainEntity = pageEntities[0];\n        if (!query.toLowerCase().includes(mainEntity.toLowerCase())) {\n            query = `${mainEntity} ${query}`;\n        }\n    }\n    // Adicionar domínio se relevante\n    if (pageUrl) {\n        const domain = new URL(pageUrl).hostname.replace('www.', '');\n        const siteName = domain.split('.')[0];\n        // Adicionar site se for relevante para a busca\n        if (['youtube', 'amazon', 'mercadolivre', 'olx', 'linkedin'].includes(siteName)) {\n            query = `site:${domain} ${query}`;\n        }\n    }\n    return query.trim();\n}\n/**\n * Extrai entidades importantes do contexto da página\n */\nfunction extractEntitiesFromContext(context) {\n    const entities = [];\n    // Extrair títulos e cabeçalhos (geralmente são entidades importantes)\n    const titleMatches = context.match(/H[1-6]: ([^\\\\n]+)/g);\n    if (titleMatches) {\n        titleMatches.forEach(match => {\n            const title = match.replace(/H[1-6]: /, '').trim();\n            if (title.length > 3 && title.length < 100) {\n                entities.push(title);\n            }\n        });\n    }\n    // Extrair nomes próprios (palavras capitalizadas)\n    const properNouns = context.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b/g);\n    if (properNouns) {\n        properNouns.forEach(noun => {\n            if (noun.length > 3 && noun.length < 50 && !entities.includes(noun)) {\n                entities.push(noun);\n            }\n        });\n    }\n    return entities.slice(0, 3); // Retornar apenas as 3 mais relevantes\n}\n/**\n * Realiza pesquisa usando Google Custom Search API\n */\nfunction searchGoogle(query_1) {\n    return __awaiter(this, arguments, void 0, function* (query, options = {}) {\n        var _a;\n        const startTime = Date.now();\n        // Configurações da API (você precisará configurar essas chaves)\n        const API_KEY = yield getGoogleSearchApiKey();\n        const SEARCH_ENGINE_ID = yield getGoogleSearchEngineId();\n        if (!API_KEY || !SEARCH_ENGINE_ID) {\n            throw new Error('Google Search API não configurada');\n        }\n        const params = new URLSearchParams({\n            key: API_KEY,\n            cx: SEARCH_ENGINE_ID,\n            q: query,\n            num: Math.min(options.maxResults || 5, 10).toString(),\n            safe: options.safeSearch ? 'active' : 'off',\n            lr: options.language || 'lang_pt',\n            gl: options.region || 'br'\n        });\n        if (options.timeRange) {\n            const timeMap = {\n                'day': 'd1',\n                'week': 'w1',\n                'month': 'm1',\n                'year': 'y1'\n            };\n            params.append('dateRestrict', timeMap[options.timeRange]);\n        }\n        const response = yield fetch(`https://www.googleapis.com/customsearch/v1?${params}`);\n        if (!response.ok) {\n            throw new Error(`Google Search API error: ${response.status}`);\n        }\n        const data = yield response.json();\n        const results = (data.items || []).map((item, index) => ({\n            title: item.title,\n            url: item.link,\n            snippet: item.snippet,\n            displayUrl: item.displayLink,\n            position: index + 1\n        }));\n        return {\n            query,\n            results,\n            totalResults: parseInt(((_a = data.searchInformation) === null || _a === void 0 ? void 0 : _a.totalResults) || '0'),\n            searchTime: Date.now() - startTime,\n            source: 'google'\n        };\n    });\n}\n/**\n * Realiza pesquisa usando SerpAPI (alternativa mais simples)\n */\nfunction searchSerpAPI(query_1) {\n    return __awaiter(this, arguments, void 0, function* (query, options = {}) {\n        var _a;\n        const startTime = Date.now();\n        const API_KEY = yield getSerpApiKey();\n        if (!API_KEY) {\n            throw new Error('SerpAPI não configurada');\n        }\n        const params = new URLSearchParams({\n            api_key: API_KEY,\n            engine: 'google',\n            q: query,\n            num: Math.min(options.maxResults || 5, 10).toString(),\n            hl: options.language || 'pt',\n            gl: options.region || 'br',\n            safe: options.safeSearch ? 'active' : 'off'\n        });\n        const response = yield fetch(`https://serpapi.com/search?${params}`);\n        if (!response.ok) {\n            throw new Error(`SerpAPI error: ${response.status}`);\n        }\n        const data = yield response.json();\n        const results = (data.organic_results || []).map((item, index) => ({\n            title: item.title,\n            url: item.link,\n            snippet: item.snippet,\n            displayUrl: item.displayed_link,\n            position: index + 1\n        }));\n        return {\n            query,\n            results,\n            totalResults: ((_a = data.search_information) === null || _a === void 0 ? void 0 : _a.total_results) || 0,\n            searchTime: Date.now() - startTime,\n            source: 'serpapi'\n        };\n    });\n}\n/**\n * Função principal de pesquisa web com fallback\n */\nexport function performWebSearch(query_1) {\n    return __awaiter(this, arguments, void 0, function* (query, options = {}) {\n        console.log(`[WebSearch] Pesquisando: \"${query}\"`);\n        try {\n            // Tentar SerpAPI primeiro (mais simples de configurar)\n            return yield searchSerpAPI(query, options);\n        }\n        catch (serpError) {\n            console.warn('[WebSearch] SerpAPI falhou, tentando Google:', serpError);\n            try {\n                // Fallback para Google Custom Search\n                return yield searchGoogle(query, options);\n            }\n            catch (googleError) {\n                console.error('[WebSearch] Todas as APIs falharam:', { serpError, googleError });\n                throw new Error('Pesquisa web indisponível no momento');\n            }\n        }\n    });\n}\n/**\n * Combina resultados de pesquisa com contexto da página\n */\nexport function combineSearchWithPageContext(pageContext, searchResults, userQuestion) {\n    const searchSummary = searchResults.results\n        .slice(0, 3) // Usar apenas os 3 primeiros resultados\n        .map(result => `**${result.title}**\\n${result.snippet}\\nFonte: ${result.displayUrl}`)\n        .join('\\n\\n');\n    return `CONTEXTO DA PÁGINA ATUAL:\n${pageContext}\n\nINFORMAÇÕES ADICIONAIS DA WEB (pesquisa: \"${searchResults.query}\"):\n${searchSummary}\n\nPERGUNTA DO USUÁRIO: ${userQuestion}\n\nUse tanto o contexto da página quanto as informações da web para fornecer uma resposta completa e útil.`;\n}\n// Funções para obter chaves de API (implementar conforme necessário)\nfunction getGoogleSearchApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get('googleSearchApiKey');\n        return result.googleSearchApiKey || null;\n    });\n}\nfunction getGoogleSearchEngineId() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get('googleSearchEngineId');\n        return result.googleSearchEngineId || null;\n    });\n}\nfunction getSerpApiKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get('serpApiKey');\n        return result.serpApiKey || null;\n    });\n}\n/**\n * Função utilitária para testar se as APIs estão configuradas\n */\nexport function checkWebSearchAvailability() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const serpApiKey = yield getSerpApiKey();\n        const googleApiKey = yield getGoogleSearchApiKey();\n        const googleEngineId = yield getGoogleSearchEngineId();\n        const serpapi = !!serpApiKey;\n        const google = !!(googleApiKey && googleEngineId);\n        return {\n            serpapi,\n            google,\n            available: serpapi || google\n        };\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// src/background/main.ts - VERSÃO COM CACHE, PERFORMANCE E TRATAMENTO DE ERROS ROBUSTO\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport { getGeminiApiKey } from \"./config\";\nimport { ErrorFactory, ErrorLogger, withErrorHandling, withTimeout } from \"../utils/errors\";\nimport { aiResponseCache, pageContextCache } from \"../utils/cache\";\nimport { throttle, performanceMonitor } from \"../utils/performance\";\nimport { captureFullPage } from \"../utils/fullPageCapture\";\nimport { performWebSearch, needsWebSearch, extractSearchQuery, combineSearchWithPageContext, checkWebSearchAvailability } from \"../utils/webSearch\";\n// Instância global que será inicializada quando necessário\nlet genAI = null;\nlet model = null;\n// Funções auxiliares para cache e performance\nconst throttledAIRequest = throttle(makeAIRequest, 1000);\n/**\n * Gera chave de cache baseada no conteúdo da página\n */\nfunction generateCacheKey(url, content) {\n    const contentHash = btoa(content.substring(0, 1000)).substring(0, 32);\n    return `${url}_${contentHash}`;\n}\n/**\n * Função genérica para fazer requisições à IA com cache e retry\n */\nfunction makeAIRequest(prompt, parts, cacheKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return performanceMonitor.measure('ai_request', () => __awaiter(this, void 0, void 0, function* () {\n            // Verifica cache se a chave foi fornecida\n            if (cacheKey) {\n                const cached = yield aiResponseCache.get(cacheKey);\n                if (cached) {\n                    console.log(`[CACHE] Cache hit for key: ${cacheKey}`);\n                    return { response: { text: () => cached } };\n                }\n            }\n            // Implementa retry com timeouts progressivos\n            const maxRetries = 2;\n            const timeouts = [10000, 20000]; // 10s, 20s\n            for (let attempt = 0; attempt <= maxRetries; attempt++) {\n                try {\n                    console.log(`[AI] Tentativa ${attempt + 1}/${maxRetries + 1} - Timeout: ${timeouts[attempt] || 20000}ms`);\n                    const result = yield withTimeout(() => model.generateContent([prompt, ...parts]), timeouts[attempt] || 20000, `ai_request_attempt_${attempt + 1}`);\n                    const responseText = result.response.text();\n                    // Armazena no cache se a chave foi fornecida\n                    if (cacheKey && responseText) {\n                        yield aiResponseCache.set(cacheKey, responseText);\n                        console.log(`[CACHE] Cache stored for key: ${cacheKey}`);\n                    }\n                    return result;\n                }\n                catch (error) {\n                    console.log(`[AI] Tentativa ${attempt + 1} falhou:`, error.message);\n                    // Se é a última tentativa, lança o erro\n                    if (attempt === maxRetries) {\n                        throw error;\n                    }\n                    // Aguarda antes da próxima tentativa\n                    yield new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n                }\n            }\n        }));\n    });\n}\n/**\n * Inicializa o cliente Gemini AI com a API key do storage\n * @throws {ApiKeyError} Se a API key não estiver configurada\n * @throws {StorageError} Se houver erro ao acessar o storage\n */\nfunction initializeGeminiAI() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield withErrorHandling(() => __awaiter(this, void 0, void 0, function* () {\n            const apiKey = yield getGeminiApiKey();\n            if (!apiKey) {\n                throw ErrorFactory.apiKeyNotConfigured();\n            }\n            genAI = new GoogleGenerativeAI(apiKey);\n            model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\n        }), (error) => {\n            if (error.code === 'API_KEY_ERROR' || error.code === 'STORAGE_ERROR') {\n                return error;\n            }\n            return ErrorFactory.geminiApiFailure(error);\n        });\n    });\n}\nchrome.commands.onCommand.addListener((command) => __awaiter(void 0, void 0, void 0, function* () {\n    if (command === \"open_chat\") {\n        yield chrome.storage.local.clear();\n        yield chrome.action.openPopup();\n    }\n}));\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.type === \"CAPTURE_FULL_PAGE\") {\n        // Usar função assíncrona separada para evitar problemas de message port\n        (() => __awaiter(void 0, void 0, void 0, function* () {\n            try {\n                console.log('[Background] Iniciando captura de página completa...');\n                const fullPageResult = yield captureFullPage(request.tabId, request.windowId, {\n                    maxHeight: 8000,\n                    quality: 70,\n                    format: 'jpeg',\n                    waitTime: 200 // Reduzido para evitar rate limit\n                });\n                console.log(`[Background] Captura completa: ${fullPageResult.segments} segmentos, ${fullPageResult.captureTime}ms`);\n                sendResponse(fullPageResult);\n            }\n            catch (error) {\n                console.error('[Background] Erro na captura de página completa:', error);\n                sendResponse({ error: `Erro na captura: ${error}` });\n            }\n        }))();\n        return true; // Manter porta aberta para resposta assíncrona\n    }\n    else if (request.type === \"START_MULTIMODAL_CHAT\") {\n        const runChatInitialization = () => __awaiter(void 0, void 0, void 0, function* () {\n            var _a, _b;\n            try {\n                // Verifica se a API key está configurada e inicializa o modelo\n                if (!model) {\n                    try {\n                        yield initializeGeminiAI();\n                    }\n                    catch (error) {\n                        const errorMessage = error.userMessage || 'API key do Gemini não configurada. Por favor, configure nas opções da extensão.';\n                        sendResponse({ error: errorMessage });\n                        return;\n                    }\n                }\n                const { fullPageResult, pageContext } = request;\n                // Validar se a captura completa foi bem-sucedida\n                if (!fullPageResult || fullPageResult.error) {\n                    throw new Error(`Captura de página falhou: ${(fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.error) || 'Resultado vazio'}`);\n                }\n                // Usar screenshot da captura completa\n                const screenshotDataUrl = fullPageResult.screenshot;\n                // Validação adicional do screenshot\n                if (!screenshotDataUrl || screenshotDataUrl.length < 100) {\n                    throw new Error('Screenshot da página completa está vazio ou inválido');\n                }\n                console.log(`[Background] Screenshot válido recebido: ${screenshotDataUrl.length} caracteres`);\n                // Destilação de contexto com cache inteligente\n                const url = ((_a = sender.tab) === null || _a === void 0 ? void 0 : _a.url) || 'unknown';\n                const contextCacheKey = generateCacheKey(url, pageContext.htmlContent || '');\n                // Verifica cache de contexto da página primeiro\n                let distilledContext = yield pageContextCache.get(contextCacheKey);\n                if (!distilledContext) {\n                    const distillationResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                        // Usa o screenshot já capturado pelo popup\n                        // Validação final antes de usar com a IA\n                        if (!screenshotDataUrl || screenshotDataUrl.length < 100) {\n                            throw new Error(\"Screenshot da página completa não disponível ou inválido\");\n                        }\n                        console.log(`[Background] Usando captura completa: ${fullPageResult.segments} segmentos, ${fullPageResult.captureTime}ms, ${screenshotDataUrl.length} chars`);\n                        // Prompt otimizado e mais direto\n                        const prompt = `Analise esta página web brevemente. Liste apenas os pontos principais: conteúdo, funcionalidades e elementos importantes. Seja conciso.`;\n                        const imagePart = {\n                            inlineData: {\n                                data: screenshotDataUrl.split(',')[1],\n                                mimeType: 'image/jpeg'\n                            }\n                        };\n                        // Limita o conteúdo HTML para evitar requisições muito grandes\n                        const limitedHtmlContent = (pageContext.htmlContent || '').substring(0, 2000);\n                        return yield makeAIRequest(prompt, [imagePart, limitedHtmlContent], `distill_${contextCacheKey}`);\n                    }), (error) => ErrorFactory.geminiApiFailure(error));\n                    distilledContext = yield distillationResult.response.text();\n                    // Armazena contexto no cache de página\n                    if (distilledContext) {\n                        yield pageContextCache.set(contextCacheKey, distilledContext);\n                    }\n                }\n                // Garante que distilledContext não seja null\n                const finalContext = distilledContext || 'Contexto não disponível';\n                yield chrome.storage.local.set({ distilledContext: finalContext });\n                // Geração da saudação com tratamento de erro\n                const openingResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                    var _a, _b;\n                    const friendlyPrompt = `Você é um colega de trabalho experiente e amigável que acabou de passar pela mesa do usuário e viu o que ele está fazendo no navegador.\n\nCONTEXTO COMPLETO DA PÁGINA:\nTítulo: ${pageContext.title}\nURL: ${(fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.url) || 'N/A'}\nDimensões capturadas: ${(_a = fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.dimensions) === null || _a === void 0 ? void 0 : _a.width}x${(_b = fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.dimensions) === null || _b === void 0 ? void 0 : _b.height}px\nSegmentos de tela: ${(fullPageResult === null || fullPageResult === void 0 ? void 0 : fullPageResult.segments) || 1}\nConteúdo: ${pageContext.textContent}\n\nVocê pode ver a página COMPLETA (não apenas o que está visível), incluindo todo o conteúdo que pode estar fora da tela. Use essa visão completa para oferecer ajuda mais precisa.\n\nAborde o usuário de forma natural e amigável, como se você tivesse visto o que ele está fazendo e quer ajudar. Seja proativo e útil!\n\nExemplos de abordagem:\n- \"Opa! Vi que você está no [site/conteúdo]. Posso te ajudar com alguma coisa?\"\n- \"Interessante esse [tópico]! Tem alguma dúvida específica que eu posso esclarecer?\"\n- \"Notei que você está pesquisando sobre [assunto]. Quer que eu complemente com algumas informações?\"\n\nSeja sempre útil e tente fornecer informações valiosas baseadas no que você vê na tela COMPLETA.`;\n                    return yield withTimeout(() => model.generateContent(friendlyPrompt), 15000, 'greetingGeneration');\n                }), (error) => ErrorFactory.geminiApiFailure(error));\n                const initialMessage = { role: 'model', text: openingResult.response.text() };\n                sendResponse(initialMessage);\n                // Salvar TANTO a conversa QUANTO o contexto completo para continuidade\n                yield chrome.storage.local.set({\n                    activeConversation: { url: (_b = sender.tab) === null || _b === void 0 ? void 0 : _b.url, history: [initialMessage] },\n                    fullPageContext: fullPageResult // Salvar screenshot e metadados completos\n                });\n                console.log('[Background] Contexto completo salvo para continuidade do chat');\n            }\n            catch (error) {\n                ErrorLogger.log(error);\n                const errorMessage = error.userMessage || `Erro ao analisar a página: ${error.message}`;\n                sendResponse({ error: errorMessage });\n            }\n        });\n        runChatInitialization();\n        return true;\n    }\n    else if (request.type === \"SEND_CHAT_MESSAGE\") {\n        const runContinueChat = () => __awaiter(void 0, void 0, void 0, function* () {\n            var _a;\n            try {\n                // Verifica se a API key está configurada e inicializa o modelo\n                if (!model) {\n                    try {\n                        yield initializeGeminiAI();\n                    }\n                    catch (error) {\n                        const errorMessage = error.userMessage || 'API key do Gemini não configurada. Por favor, configure nas opções da extensão.';\n                        sendResponse({ error: errorMessage });\n                        return;\n                    }\n                }\n                const currentHistory = request.history;\n                // Recuperar TANTO o contexto destilado QUANTO o screenshot original\n                const data = yield chrome.storage.local.get(['distilledContext', 'fullPageContext']);\n                if (!data.distilledContext)\n                    throw new Error(\"Contexto destilado não encontrado.\");\n                // Obter a última pergunta do usuário\n                const lastUserMessage = currentHistory[currentHistory.length - 1];\n                const userQuestion = (lastUserMessage === null || lastUserMessage === void 0 ? void 0 : lastUserMessage.text) || '';\n                // Primeira tentativa: resposta com contexto da página\n                const initialResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                    var _a, _b, _c;\n                    // Preparar conteúdo multimodal se screenshot estiver disponível\n                    const parts = [];\n                    // Adicionar screenshot se disponível (mantém contexto visual)\n                    if ((_a = data.fullPageContext) === null || _a === void 0 ? void 0 : _a.screenshot) {\n                        parts.push({\n                            inlineData: {\n                                mimeType: \"image/jpeg\",\n                                data: data.fullPageContext.screenshot.split(',')[1]\n                            }\n                        });\n                        console.log('[Background] Usando screenshot completo na continuação do chat');\n                    }\n                    // Prompt melhorado que mantém contexto visual + textual\n                    const contextPrompt = `Você é um colega de trabalho amigável que pode ver esta página completa.\n\nCONTEXTO DA PÁGINA:\n${data.distilledContext}\n\n${data.fullPageContext ? `INFORMAÇÕES ADICIONAIS:\n- Dimensões: ${(_b = data.fullPageContext.dimensions) === null || _b === void 0 ? void 0 : _b.width}x${(_c = data.fullPageContext.dimensions) === null || _c === void 0 ? void 0 : _c.height}px\n- Segmentos capturados: ${data.fullPageContext.segments}\n- URL: ${data.fullPageContext.url}\n` : ''}\nVocê pode ver a página COMPLETA (incluindo partes fora da tela) e deve usar tanto a visão visual quanto o contexto textual para responder.\n\nSe a informação não estiver visível na página, responda \"PRECISO_PESQUISAR\" seguido de uma explicação breve do que precisa buscar. Use formatação Markdown.\n\nHISTÓRICO DA CONVERSA:`;\n                    parts.push({ text: contextPrompt });\n                    const promptForGenerativeModel = [\n                        { role: \"user\", parts },\n                        ...currentHistory.map(msg => ({ role: msg.role, parts: [{ text: msg.text }] }))\n                    ];\n                    return yield withTimeout(() => model.generateContent({ contents: promptForGenerativeModel }), 20000, 'chatContinuation');\n                }), (error) => ErrorFactory.geminiApiFailure(error));\n                const initialResponse = initialResult.response.text();\n                // Verificar se precisa de pesquisa web\n                const needsSearch = needsWebSearch(initialResponse, userQuestion) || initialResponse.includes('PRECISO_PESQUISAR');\n                let finalResult = initialResult;\n                if (needsSearch) {\n                    console.log('[Background] IA indicou necessidade de pesquisa web');\n                    // Verificar se pesquisa web está disponível\n                    const searchAvailability = yield checkWebSearchAvailability();\n                    if (searchAvailability.available) {\n                        try {\n                            // Extrair query de pesquisa\n                            const searchQuery = extractSearchQuery(userQuestion, data.distilledContext, (_a = data.fullPageContext) === null || _a === void 0 ? void 0 : _a.url);\n                            console.log(`[Background] Pesquisando na web: \"${searchQuery}\"`);\n                            // Realizar pesquisa\n                            const searchResults = yield performWebSearch(searchQuery, {\n                                maxResults: 3,\n                                language: 'pt',\n                                region: 'br'\n                            });\n                            // Combinar contexto da página com resultados da pesquisa\n                            const enhancedContext = combineSearchWithPageContext(data.distilledContext, searchResults, userQuestion);\n                            // Gerar resposta final com contexto expandido\n                            const enhancedResult = yield withErrorHandling(() => __awaiter(void 0, void 0, void 0, function* () {\n                                var _a;\n                                const parts = [];\n                                // Adicionar screenshot se disponível\n                                if ((_a = data.fullPageContext) === null || _a === void 0 ? void 0 : _a.screenshot) {\n                                    parts.push({\n                                        inlineData: {\n                                            mimeType: \"image/jpeg\",\n                                            data: data.fullPageContext.screenshot.split(',')[1]\n                                        }\n                                    });\n                                }\n                                const enhancedPrompt = `Você é um colega de trabalho expert que tem acesso tanto à página atual quanto a informações da web.\n\n${enhancedContext}\n\nAgora responda de forma completa e útil, combinando as informações da página com os dados da web. Seja natural e amigável, como um colega que realmente quer ajudar.\n\nHISTÓRICO DA CONVERSA:`;\n                                parts.push({ text: enhancedPrompt });\n                                const promptForGenerativeModel = [\n                                    { role: \"user\", parts },\n                                    ...currentHistory.map(msg => ({ role: msg.role, parts: [{ text: msg.text }] }))\n                                ];\n                                return yield withTimeout(() => model.generateContent({ contents: promptForGenerativeModel }), 25000, 'enhancedChatContinuation');\n                            }), (error) => ErrorFactory.geminiApiFailure(error));\n                            finalResult = enhancedResult;\n                            console.log(`[Background] Resposta gerada com pesquisa web (${searchResults.results.length} resultados)`);\n                        }\n                        catch (searchError) {\n                            console.error('[Background] Erro na pesquisa web:', searchError);\n                            // Usar resposta inicial se pesquisa falhar\n                            console.log('[Background] Usando resposta inicial devido a erro na pesquisa');\n                        }\n                    }\n                    else {\n                        console.log('[Background] Pesquisa web não disponível (APIs não configuradas)');\n                        // Modificar resposta inicial para informar sobre limitação\n                        const limitedResponse = initialResponse.replace('PRECISO_PESQUISAR', 'Hmm, essa informação não está visível nesta página. Para ter acesso a pesquisas na web, é necessário configurar uma API de busca nas configurações da extensão.');\n                        finalResult = {\n                            response: {\n                                text: () => limitedResponse\n                            }\n                        };\n                    }\n                }\n                const result = finalResult;\n                const newAIMessage = { role: 'model', text: result.response.text() };\n                sendResponse({ text: newAIMessage.text });\n                const updatedHistory = [...currentHistory, newAIMessage];\n                const currentConversation = yield chrome.storage.local.get(\"activeConversation\");\n                yield chrome.storage.local.set({\n                    activeConversation: Object.assign(Object.assign({}, currentConversation.activeConversation), { history: updatedHistory })\n                });\n            }\n            catch (error) {\n                ErrorLogger.log(error);\n                const errorMessage = error.userMessage || error.message;\n                sendResponse({ error: errorMessage });\n            }\n        });\n        runContinueChat();\n        return true;\n    }\n});\n"],"names":[],"sourceRoot":""}